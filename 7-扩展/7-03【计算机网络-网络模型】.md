# 第一章 网络体系介绍

计算机网络体系可以大致分为一下三种，OSI七层模型、TCP/IP四层模型和五层模型。

- OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。
- TCP/IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP/IP只有最上面三层，最下面一层没有什么具体内容，TCP/IP参考模型没有真正描述这一层的实现。
- 五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。

![](..\图片\7-03【计算机网络-网络模型】\1-1.png)

## 1.1 OSI网络七层模型

OSI网络七层模型是ISO组织定义的国际通用标准模型，其目的是为了制定全球统一的网络模型标准，让全球内的国家、组织可以实现网络互通。OSI网络七层模型分别为：**应用--表示--会话--传输--网络--数据链路--物理**

* **应用层**：给用户和抽象的网络之间提供一个接口，为应用程序提供交互服务。常见协议有：TELENT、HTTP、HTTPS、FTP、DNS、POP3、SMTP等。
* **表示层**：表示层提供各种数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。例如：数据格式变化、数据加密与解密、数据压缩与解压等。常见协议有：Rlogin, SNMP, Gopher。
* **会话层**：会话层就是负责建立、管理和终止两个节点（应用程序）之间的通信会话。负责维护两个节点之间的传输联接，确保点到点传输不中断，以及管理数据交换等功能。
* **传输层**：传输层实现了网络中不同主机上的用户进程之间的数据通信，为用户提供了端到端的服务。定义了传输数据的协议端口号，以及流量控制和差错校验。常见协议有：TCP、UDP。
* **网络层**：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。IP协议是Internet的基础。常见协议有：IP, ICMP, ARP, RARP, AKP, UUCP。
* **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
* **物理层**：物理层的作用就是提供了网络的双向通讯，为双向传输提供了有保障的通路。考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

就像一个公司要分很多部门一样，每个部门各司其职，网络模型分层的目的也是为了这样，另外分层还能达到降低复杂性、统一标准、工程模块化、快速发展、易于学习掌握等目的。

公司的部门和部门之间肯定是有一定联系的。所以在OSI七层模型中，相邻层之间也都是有联系的，这个联系就叫做服务接入点，简称SA(service access)。所以正是因为相邻两层之间有SA，这两层之间才会有联系。相邻两层之间必须有服务接入点。

## 1.2 TCP/IP网络协议四层模型

**TCP/IP**（`Transmission Control Protocol/Internet Protocol`，传输控制协议/网际协议）指能够在多个不同网络间实现信息传输的协议簇。该协议具有很强的灵活性，支持任意规模的网络，几乎可连接所有服务器和工作站。定义了主机如何连入因特网及数据如何在它们之间传输的标准。

TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由TCP、IP、UDP、FTP、SMTP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。

TCP/IP协议在一定程度上参考了OSI的体系结构。不同于ISO模型的七个分层，TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中：**应用--传输--网络--网络接口层**。数据链路层和物理层合并为网络接口层。网络层也称为IP层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

![](..\图片\7-03【计算机网络-网络模型】\1-2.png)

接下来详细介绍一下TCP/IP网络协议四层模型。

# 第二章 应用层

“应用层”的作用，就是向**用户提供一组常用的应用程序，规定应用程序的数据格式**。比如电子邮件、文件传输访问、远程登录等。

TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。

我们常见应用层的网络服务协议有：HTTP、HTTPS、DNS、FTP、DHCP、TELNET、SMTP、POP3、IMAP、SNMP等。

|        应用        | 应用层协议 | 端口号  | 传输层协议 |            备注             |
| :----------------: | :--------: | :-----: | :--------: | :-------------------------: |
|   超文本传送协议   |    HTTP    |   80    |    TCP     |                             |
| 超文本传送安全协议 |   HTTPS    |   443   |    TCP     |                             |
|      域名解析      |    DNS     |   53    |  TCP/UDP   | 长度超过 512 字节时使用 TCP |
|    文件传送协议    |    FTP     |  20/21  |    TCP     |  控制连接 21，数据连接 20   |
|  动态主机配置协议  |    DHCP    |  67/68  |    UDP     |                             |
|    远程终端协议    |   TELNET   |   23    |    TCP     |                             |
|  简单邮件传送协议  |    SMTP    |   25    |    TCP     |                             |
|    邮件读取协议    |    POP3    |   110   |    TCP     |                             |
|  网际报文存取协议  |    IMAP    |   143   |    TCP     |                             |
|  简单网络管理协议  |    SNMP    | 161/162 |    UDP     |                             |

在这一层，数据的单位称为帧（frame）。

## 2.1 HTTP协议

HTTP协议是`Hyper Text Transfer Protocol`（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，定义了客户端和服务器端通信的时候，发送数据的格式。HTTP协议就是TCP/IP协议中专门用于浏览器与Web服务器之间通信的应用层协议。

通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如"HTTP/1.1 200 OK"，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据和错误纠正。

浏览器与Web服务器之间的协议是应用层协议，当前，我们主要遵循的协议为HTTP/1.1。HTTP协议是Web开发的基础，这是一个无状态的协议，客户机与服务器之间通过请求和相应完成一次会话（Session）。

![](..\图片\7-03【计算机网络-网络模型】\2-1.png)

特点如下：

- 基于`TCP/IP`的高级协议。
- 默认端口号：`80`。
- 基于请求/响应模型的：一次请求对应一次响应。
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
- HTTP 允许传输任意类型的数据。传输的类型由 `Content-Type` 加以标记。
- 支持客户端/服务器模式。

HTTP 协议由HTTP 请求和HTTP 响应组成，当在浏览器中输入网址访问某个网站时，浏览器会将请求封装成一个HTTP 请求发送给服务器站点，服务器接收到请求后会组织响应数据封装成一个HTTP 响应返回给浏览器。即没有请求就没有响应。

### 2.1.1 URI和URL

- URI：统一资源标识符。相当于共和国，所以URI更大
- URL：统一资源定位符。相当于中华人民共和国

我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。URL中描述了协议，用于检索资源和资源名称。如果是web上的资源，所用的协议就是http或者https。如果资源是文件类型的，那么使用的协议就是ftp。URL由七部分组成：

- 1：所使用的协议（http,ftp）
- 2：服务器的位置（IP号）
- 3：服务器上的端口号（0~65535）
- 4：资源所在的路径
- 5：参数（访问该资源所带的参数）
- 6：片段（发给http服务器的数据）

![](..\图片\7-03【计算机网络-网络模型】\2-2.png)

只要能唯一标识资源的就是URI，在URI的基础上给出其资源的访问方式的就是URL。

### 2.1.1 请求消息

请求消息：客户端发给服务器端的数据

```java
// 请求行
POST /login.html HTTP/1.1

// Chrome浏览器请求头
Host: localhost
Connection: keep-alive
Cache-Control: max-age=0

// 请求空行

// 请求体，只有POST有，是参数
username = zhangsan
```

数据格式如下：请求行、请求头、请求空行、请求体。

1. 请求行：`请求方式 请求URL 请求协议/版本`，实例：`GET /login.html HTTP/1.1`。包括请求方法，访问的资源 URL，使用的 HTTP 版本。`GET`和`POST`是最常见的 HTTP 方法，除此以外还包括`DELETE、HEAD、OPTIONS、PUT、TRACE`。新增POST、修改PUT。

2. 请求头：`请求头名称: 请求头值`。格式为“属性名:属性值”，服务端根据请求头获取客户端的信息，主要有`cookie、host、connection、accept-language、accept-encoding、user-agent`。

   `User-Agent`：浏览器告诉服务器，访问服务器使用的浏览器款式。这样可以让服务器获取头信息，解决浏览器的兼容性问题。

   `Referer`：`http://localhost/login.html`告诉服务器，当前请求从何而来。这样有两个好处：1. 防止盗链发生。2. 统计工作。

3. 请求空行

   空行，真的只是一个空行，它主要是起了分割的作用。分割请求头和请求体。

4. 请求体(请求正文)

   在GET方法中是没有请求体的，但是在POST中是有请求体的。这是因为POST的参数不显示，都在请求体中封装POST请求消息的请求参数。

`HTTP`协议一共有着7种请求方式`GET、POST、DELETE、HEAD、OPTIONS、PUT、TRACE`。，但是常用的只有两种GET和POST。

- GET 参数通过 URL也就是请求行传递，POST参数数据 放在 Request body请求体 中。
- GET 请求在 URL 中传送的参数是有长度限制的，而 POST没有，所以POST可以用于文件的上传。
- GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。
- GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
- GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。
- GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
- GET 请求只能进行 URL 编码，而 POST 支持多种编码方式。
- GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。
- 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。

但是实际上 GET 和 POST 本质上没有区别：

- GET 和 POST 是HTTP 协议中的两种发送请求的方法，HTTP是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。

- HTTP 的底层是 TCP/IP，所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。GET 和 POST 能做的事情是一样一样的。要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的。


在万维网世界中，TCP 就像汽车，交通规则就是HTTP，浏览器和服务器就是运输公司。HTTP 给汽车运输设定了好几个服务类别，有 GET, POST, PUT, DELETE 等等。

HTTP 规定，执行 GET 请求时设置 method 为 GET，并且把传送的数据放在url 中以方便记录。如果是 POST 请求，就要设置 method 为 POST，并把传送数据放在方法体中。当然，也可以在 GET 的时候往方法体中放一些数据，在POST的时候往URL中放一些数据。HTTP 只是个行为准则，而 TCP 才是 GET 和 POST 怎么实现的基本。

上面说的是HTTP 对 GET 和 POST 参数的传送渠道（url 还是 requrest body）提出的要求，接下来说一下参数大小的限制。

浏览器和服务器就是运输公司，它们用来接收和传送数据，但是这也需要一些成本，因此会限制URL中的参数长度，不限制方法体中参数长度。如果是GET方式传数据，在方法体中放一些数据，不同的服务器处理方式不一样，有的会接收数据，有的忽略。GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

GET 和 POST 还有一个重大区别，简单的说：GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。

- 对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；
- 而对于 POST，浏览器先发送 header，服务器响应 100（continue），浏览器再发送 data，服务器响应 200（返回数据）。

![](..\图片\7-03【计算机网络-网络模型】\2-3应用层数据包.jpg)

因为 POST 需要两步，时间上消耗的要多一点，看起来 GET 比 POST 更有效。但是GET并不能替换POST：

- GET 与 POST 都有自己的语义，不能随便混用。
- 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。
- 并不是所有浏览器都会在 POST 中发送两次包，比如 Firefox 就只发送一次。

### 2.1.2 响应消息

响应消息：服务器端发送给客户端的数据

```html
<!--响应行 协议/版本 响应状态码 状态码描述-->
HTTP/1.1 200
Content-Type: text/html;charset=UTF-8
Content-Length: 100
Date: Mon, 07 Mar 2022 08:01:01 GMT
Keep-Alive: timeout=20
Connection: keep-alive
```

数据格式如下：响应行、响应头、响应空行、响应体。

1. 响应行：`协议/版本 响应状态码 状态码描述 HTTP/1.1 200`。响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。

2. 响应头：格式：`响应头名称：值`。常见的响应头有：`connection、content-type、content-encoding、content-length、set-cookie、Last-Modified、Cache-Control、Expires`。

   `Content-Type`：服务器告诉客户端本次响应体数据格式以及编码格式

   `Content-disposition`：服务器告诉客户端以什么格式打开响应体数据。`in-line`：默认值，在当前页面内部打开。不经常使用。`attachment`：以附件的形式打开响应体，通常用于文件下载。

3. 相应空行：仅仅是一个空行

4. 响应体：响应体：传输的数据。

常用的相应状态码如下：

| 状态码 | 类别                             | 原因                       |
| ------ | -------------------------------- | -------------------------- |
| 1xx    | Informational(信息性状态码)      | 接收的请求正在处理         |
| 2xx    | Success（成功状态码）            | 请求正常处理完毕           |
| 3xx    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4xx    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5xx    | Server Error（服务器错误状态码） | 服务器处理请求错误         |

| 状态码 | 含义               | 解释                                                         |
| ------ | :----------------- | ------------------------------------------------------------ |
| 200    | 成功               | 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 |
| 300    | 多种选择           | 针对请求，服务器可执行多种操作。 <br />服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择 |
| 302    | 重定向             | 服务器目前从不同位置的网页响应请求，<br />但请求者应继续使用原有位置来进行以后的请求 |
| 304    | 未修改（请求缓存） | 自从上次请求后，请求的网页未修改过。 <br />服务器返回此响应时，不会返回网页内容 |
| 305    | 使用代理           | 请求者只能使用代理访问请求的网页。 <br />如果服务器返回此响应，还表示请求者应使用代理 |
| 400    | 错误请求           | 服务器不理解请求的语法                                       |
| 401    | 未授权             | 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应  |
| 403    | 禁止               | 服务器拒绝请求                                               |
| 404    | 未找到             | 服务器找不到请求的网页                                       |
| 405    | 方法禁用           | 禁用请求中指定的方法                                         |
| 500    | 服务器内部错误     | 服务器遇到错误，无法完成请求                                 |
| 502    | 错误网关           | 服务器作为网关或代理，从上游服务器收到无效响应               |
| 503    | 服务不可用施       | 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态 |
| 504    | 网关超时           | 服务器作为网关或代理，但是没有及时从上游服务器收到请求       |

### 2.1.3 HTTP1.0和HTTP1.1

区别如下：

- 长连接：HTTP1.0 默认使用短连接，每次请求都需要建立新的 TCP 连接，连接不能复用。HTTP1.1 支持长连接，复用 TCP 连接，允许客户端通过同一连接发送多个请求。不过，这个优化策略也存在问题，当一个队头的请求不能收到响应的资源时，它将会阻塞后面的请求。这就是“队头阻塞”问题。
- 断点续传：HTTP1.0 不支持断点续传。HTTP1.1 新增了 range 字段，用来指定数据字节位置，支持断点续传。
- 错误状态响应码：在 HTTP1.1 中新增了 24 个错误状态响应码，如`409（Conflict）`表示请求的资源与资源的当前状态发生冲突、`410（Gone）`表示服务器上的某个资源被永久性的地删除。
- Host 头处理：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名。到了 HTTP1.1 时代，虚拟主机技术发展迅速，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址，故 HTTP1.1 增加了 HOST 信息。

### 2.1.4 HTTP1.1和HTTP2.0

- 新的二进制格式：HTTP1.1 基于文本格式传输数据；HTTP2.0 采用二进制格式传输数据，解析更高效。
- 多路复用：在一个连接里，允许同时发送多个请求或响应，并且这些请求或响应能够并行地传输而不被阻塞，避免 HTTP1.1 出现的“队头堵塞”问题。
- 头部压缩，HTTP1.1 的 header 带有大量信息，而且每次都要重复发送；HTTP2.0 把 header 从数据中分离，并封装成头帧和数据帧，使用特定算法压缩头帧，有效减少头信息大小。并且 HTTP2.0 在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。比如请求 a 发送了所有的头信息字段，请求 b 则只需要发送差异数据，这样可以减少冗余数据，降低开销。
- 服务端推送：HTTP2.0 允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。

## 2.2 HTTPS协议

HTTPS 原理：首先是 TCP 三次握手，然后客户端发起一个 HTTPS 连接建立请求，客户端先发一个`Client Hello`的包，然后服务端响应`Server Hello`，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。

- 协商加密算法 。在`Client Hello`里面客户端会告知服务端自己当前的一些信息，包括客户端要使用的 TLS 版本，支持的加密算法，要访问的域名，给服务端生成的一个随机数（Nonce）等。需要提前告知服务器想要访问的域名以便服务器发送相应的域名的证书过来。
- 服务端响应`Server Hello`，告诉客户端服务端选中的加密算法。

- 接着服务端给客户端发来了 2 个证书。第二个证书是第一个证书的签发机构（CA）的证书。

- 客户端使用证书的认证机构 CA 公开发布的 RSA 公钥对该证书进行验证。

- 验证通过之后，浏览器和服务器通过密钥交换算法产生共享的对称密钥。

- 开始传输数据，使用同一个对称密钥来加解密。

HTTP与HTTS区别如下：

1. HTTP 是超文本传输协议，信息是明文传输；HTTPS 则是具有安全性的 ssl 加密传输协议。
2. HTTP 和 HTTPS 用的端口不一样，HTTP 端口是 80，HTTPS 是 443。
3. HTTPS 协议需要到 CA 机构申请证书，一般需要一定的费用。
4. HTTP 运行在 TCP 协议之上；HTTPS 运行在 SSL 协议之上，SSL 运行在 TCP 协议之上。

## 2.3 DNS域名系统

DNS (域名系统)：端口号53，用于解析DNS。

DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。

域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。

![](..\图片\7-03【计算机网络-网络模型】\2-4DNS域名系统.jpg)

DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：

- 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。
- 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。

## 2.4 FTP文件传送协议

FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：

- 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。
- 数据连接：用来传送一个文件数据。

根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：

- 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0\~1023 是熟知端口号。

  ![](..\图片\7-03【计算机网络-网络模型】\2-5FTP文件传送协议.jpg)

- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。

  ![](..\图片\7-03【计算机网络-网络模型】\2-6文件传送协议.jpg)

主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。

filezilla使用的就是FTP协议来传输文件。

## 2.5 DHCP动态主机配置协议

DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。

DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。

DHCP 工作过程如下：

1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。

2. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。

3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。

4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。

   ![](..\图片\7-03【计算机网络-网络模型】\2-7DHCP动态主机配置协议.jpg)

## 2.6 TELNET远程登录协议

TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。

TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。

## 2.7 电子邮件协议

一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。

邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。

![](..\图片\7-03【计算机网络-网络模型】\2-8电子邮件协议.png)

**SMTP**

SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。

![](..\图片\7-03【计算机网络-网络模型】\2-9SMTP协议.png)

**POP3**

POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。

**IMAP**

IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。

## 2.8 Web 页面请求过程

DHCP 配置主机信息

- 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。

- 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。

- 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。

- 该数据报则被放置在 MAC 帧中，将广播到与交换机连接的所有设备。

- 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段被放入 IP 数据报中，最后放入 MAC 帧中。

- 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。

- 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

ARP 解析 MAC 地址

- 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。

- 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。

- 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。

- 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。

- DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。

- 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。

- 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。

DNS 解析域名

- 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。

- 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。

- 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。

- 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。

- 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。

HTTP 请求页面

- 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。

- 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。

- HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。

- 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。

- HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。

- 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。

# 第三章 传输层

网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

传输层：建立端口到端口的通信。在这一层，数据的单位称为 段 （segment）

传输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。

## 3.1 端口

端口：我们通过IP和Mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。

“传输层”的功能，就是建立“端口到端口”的通信，相比之下，“网络层”的功能是建立“主机到主机”的通信，只要确定主机和端口，我们就能实现程序之间的交流。

## 3.2 Socket

Socket，套接字。

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

![](..\图片\7-03【计算机网络-网络模型】\3-1Socket.jpg)

 一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。

![](..\图片\7-03【计算机网络-网络模型】\3-2Socket.jpg)

服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。

使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是“一切皆socket”。

socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –> 读写write/read –> 关闭close”模式来操作。socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。

## 3.3 TCP协议

TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

因为是面向连接的协议，也就是说：在收发数据前必须和对方建立可靠的连接。  一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，简单的说一下：

1. 主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；
2. 主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 、“可以，你什么时候发？”，这是第二次对话；
3. 主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。

三次“对话”的目的是使数据包的发送和接收同步， 经过三次“对话”之后，主机A才向主机B正式发送数据。

接下来详细的介绍一下：TCP数据包的格式：

<img src="..\图片\7-03【计算机网络-网络模型】\3-3TCP数据包.png" style="zoom:50%;" />

-   **序号seq** ：占4个字节也就是32个比特位，用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

-   **确认号ack** ：占4个字节，期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

-   **数据偏移**：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

-   **确认 ACK**：占1个比特位，当 ACK=1时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

-   **同步 SYN**：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

-   **终止 FIN**：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

-   **窗口**：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

### 3.3.1 三次握手

<img src="..\图片\7-03【计算机网络-网络模型】\3-4三次握手.png" style="zoom:50%;" />

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号seq=x，并进入SYN_SENT状态，等待服务器确认。

- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，选择一个初始的序号 y，确认号ack为 x+1，此时B进入SYN_RCVD（SYN_RECEIVED接收）状态。

- A 收到 B 的确认连接报文后，还要向 B 发出确认报文，ACK=1，序号seq为 x+1，确认号ack为 y+1。

- B 收到 A 的确认后，进入ESTAB_LISHED（TCP连接成功状态），连接建立。

**第三次握手的原因**

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

> 另外一个原因：第三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

**如果已经建立了连接，但客户端出现故障**

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### 3.3.2 四次挥手

序号seq、确认号ack、确认ACK、同步SYN、终止FIN。

<img src="..\图片\7-03【计算机网络-网络模型】\3-5四次挥手.jpg" style="zoom: 67%;" />

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

- A 发送连接释放报文，FIN=1，并且进入进入FIN-WAIT-1（终止等待1）状态。

- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。B进入CLOSE-WAIT（关闭等待）状态，A进入FIN-WAIT-2（终止等待2）状态。

- 当 B 不再需要连接时，发送连接释放报文，FIN=1。B进入LAST-ACK（最后确认）状态。

- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。

- B 收到 A 的确认后释放连接。

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**  

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。

- 防止已失效的连接请求报文段出现在本连接中。等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

> 所谓的2MSL是两倍的MSL(`Maximum Segment Lifetime`)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。

### 3.3.3 TCP 可靠传输

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：

![](..\图片\7-03【计算机网络-网络模型】\3-6TCP可靠传输.gif)

其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：

![](..\图片\7-03【计算机网络-网络模型】\3-7TCP可靠传输.gif)

其中 RTT<sub>d</sub> 为偏差的加权平均值。

### 3.3.4 TCP 滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

![](..\图片\7-03【计算机网络-网络模型】\3-8TCP滑动窗口.jpg)

### 3.3.5 TCP 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 3.3.6 TCP 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![](..\图片\7-03【计算机网络-网络模型】\3-9TCP拥塞控制.jpg)

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；

- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

  ![](..\图片\7-03【计算机网络-网络模型】\3-10TCP拥塞控制.png)

**慢开始与拥塞避免**

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd \>= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

**快重传与快恢复**

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

![](..\图片\7-03【计算机网络-网络模型】\3-11.png)

## 3.4 UDP协议

<img src="..\图片\7-03【计算机网络-网络模型】\3-12UDP协议.jpg" style="zoom:50%;" />

UDP（User Data Protocol，用户数据报协议），首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

1. UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
2. 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。
3. UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。
4. 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。
5. UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。
6. UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。

## 3.5 TCP和UDP区别

|              | UDP                                        | TCP                                      |
| ------------ | ------------------------------------------ | ---------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                                 |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制         |
| 是否有序     | 无序                                       | 有序，消息在传输过程中乱序 TCP会重新排序 |
| 传输速度     | 快                                         | 慢                                       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                         |
| 传输方式     | 面向报文                                   | 面向字节流                               |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节               |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输   |

1. 基于连接与无连接；
2. 对系统资源的要求（TCP较多，UDP少）；
3. UDP程序结构较简单；
4. 流模式与数据报模式 ；
5. TCP保证数据正确性，UDP可能丢包；
6. TCP保证数据顺序，UDP不保证。



# 第四章 网络/IP层

网络层：实现终端节点的通信，提供阻塞控制，为数据包选择路由，实现数据包的选路和转发。

常见协议有：IP, ICMP, ARP, RARP, AKP, UUCP。又称为IP层，足以说明IP协议在该层的重要性。

在这一层数据的单位是数据包。

## 4.1 IP协议

IP是一种 「不可靠」的 「端到端」的数据包 「传输服务」，主要实现两个功能：数据传输 和 数据分片。

IP协议是TCP/IP协议族的核心协议，也是socket网络编程的基础之一。它为上层提供无状态、无连接、不可靠的服务。

- 无状态：指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送，传输，接收都是相互独立的。这种服务最大缺点是无法处理乱序和重复的IP数据报。优点是简单高效，和UDP协议与HTTP协议相同，都是无状态协议。

- 无连接：指IP通信双方都不长久的维持对方的任何信息。这表示上层协议每次发送数据，都需要明确指定对方的IP地址。

- 不可靠：指IP协议中的IP数据报不能准确到达接收端，只是会尽最大努力。一旦发送失败，就通知上层协议，而不会试图重发。

IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。

IP协议有IPv4和IPv6，我们重点学IPv4。

### 4.1.1 IP协议头部格式

下面描述的仅仅是头部结构，整个IP数据报文有头部结构和数据部分。

IPv4头部结构如下：

![](..\图片\7-03【计算机网络-网络模型】\4-1IPv4头部结构.png)

IP协议首部与TCP协议首部非常相似，如果没有特殊情况，都是20个字节，因此我们也经常会把两者放在一起称为TCP/IP协议。下面将IP协议首部每个字段都详细介绍一下：

- 4位版本号：用来指定IP协议的版本，IPV4的版本号就是4，用4位来标识就是0100。

- 4位头部长度：表明IP头部结构的大小，标识头部最多有多少个4字节，因此单位是4字节。一共有四个比特位，因为4个比特位最大值是15，所以IPv4最大头部长度可表示有15个4字节=60字节。在默认情况下，该字段被设置为5，所以默认IP首部20字节，所以选项最多的话是40字节。

- 8位服务类型：前三位表示优先度（已经弃用），第4位表示最小延迟、第5位表示最大吞吐量、第6位表示最高可用性、第7位表示最小费用(最小代价)，这四位互相冲突，只能选择一个。需要根据不同情况进行选择，如果是SSH/TELNET这类远端登录，那么就应该选择最小延时，如果是FTP类型的程序，则应该选择最大吞吐量；第8位是保留位，目前没有使用，必须填0。

  ![](..\图片\7-03【计算机网络-网络模型】\4-2IPv3头部结构8位服务类型.png)

- 16位总长度：表示IP首部和后面携带的数据部分一共有多少个字节。该字段有16个比特位，因此IP数据报整体最大长度为2的16次方，65535个字节。

- 16位标识：数据报的唯一标识。同一个数据报的所有分片中具有相同的标识。如果一份IP报文在数据链路层被分片，那么每一片的该字段应该都是相同值。帮助对端主机在接收后进行分片重组。

- 3位标志：第一位保留，现在不使用，未来如果需要的话再使用，必须填0。第二位用来指明是否可以分片，如果为0则可以分片，如果为1则不能分片，但是假如一个IP报文禁止分片且长度还大于了MTU（Maximum Transmission Unit最大传输单元），则该本文只能被丢弃。第三位为1表示它是分片中段的报文，即后续还有分片报文，如果第三位为0则表示这是最后一片。

- 13位片偏移：该字段表示分片相对于原始IP报文开始处的偏移量，其实就是表示当前分片在原报文中所处的位置，第一个分片对应值为0。由于该字段总共13个比特位，因此最多可以表示2 ^ 13即8192个相对位置。单位为8字节，所以最大可以表示8192 * 8 = 65536个字节的位置。

- 8位生存时间：TTL（Time To Live）数据报到达目的地的最大报文跳数，一般为64。每次经过一个路由，TTL–1，如果TTL == 0时还没到达目的地，那么这个报文就会被丢弃。并向源端发送一个ICMP差错报文，目的防止数据报陷入路由循环。这个字段主要是为了防止出现路由循环，数据包在一个循环中一直转发，浪费网络资源。

- 8位协议：表示IP的上层是什么协议，我们熟知的TCP、UDP、ICMP等都是在IP上层的。

- 16位头部校验和：由发送端填充，接收端对其使用CRC算法校验IP数据报头部（仅校验头部）在传输过程中是否损坏，如果损坏直接丢弃，它只校验IP头部，不校验下面的内容，因为内容部分的校验是上层传输层TCPP）需要考虑的，IP协议只要发现首部有问题就直接丢弃该报文。

- 32位源IP地址：表示发送端的IP。

- 32位目的IP地址：表示接收端的IP。

- 选项字段：不定长，最大可以到40个字节。，可用的IP选项如下：

  - 记录路由：将数据包经由的所有路由器IP填入该段。
  - 时间戳：将数据报在每个路由器被转发时的时间填入该段。
  - 松散源路由选择：指定路由器IP地址列表，数据报发送过程中必须经过其中所有路由器
  - 严格源路由选择：类似上面，数据报只能经过被指定的路由器。

### 4.1.2 IP地址

在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。

IPV4中我们由32个二进制位来表示IP地址，习惯上我们用分成四段的十进制数表示IP地址，即将32位IP地址每8位一组，分成4组，组间用’ . '进行分隔，再将每组转换为十进制。从0.0.0.0到255.255.255.255，地址分为两个部分，前一部分代表网络，后一部分代表主机。

在IPV4标准下最多有2 ^ 32 = 4292967296个IP地址，但是能被人们使用的远远不足这个数字。（比如某些IP地址是有特殊作用被预留的，某些设备如路由器会占有多个IP地址）。因此就弄出来了IPv6，之后再说。

IP地址由网络标识（网络地址）和主机标识（主机地址）两部分组成。

* 查找到一个IP地址的过程就像旅游一样，想要去天安门玩，不可能直接坐高铁到达天安门。一定是先抵达北京市（目的网络），再通过北京市内的交通抵达天安门（目的主机）。
* 因此我们在路由选择时，应该先找到目标主机所在的局域网，再在该局域网中找到目标主机。这种方式可以快速帮我们定位到目标局域网，在局域网内搜索目标主机就比在茫茫的网络中找一台主机要快速多了。

网络号：保证互相连接的两个网段具有不同的标识。

主机号：保证在同一个网段中，两台主机具有不同的标识。

IP地址划分为五个级别，分别为A类、B类、C类、D类和E类（一直没有使用过），所以目前我们所能见到的**IP地址只有A、B、C、D四类。划分的依据就是IP地址从第1位到第4位的比特位。**

<img src="..\图片\7-03【计算机网络-网络模型】\4-3IP地址分类.png" style="zoom:67%;" />

- A类地址：0.0.0.0 ~ 127.255.255.255。该类IP地址的最前面为“0”，即前八位最大为0 1111111 (127 十进制)，但是127被用作测试使用，所以最大为126，所以地址的网络号取值于1~126之间。一般用于大型网络。
- B类地址：128.0.0.0 ~ 191.255.255.255。该类IP地址的最前面为“10”，即前八位最小值为128，最大值为191。一般用于中等规模网络。
- C类地址：192.0.0.0 ~ 223.255.255.255。该类IP地址最前面为“110”，即前八位最小值为192，最大值为223。一般用于小型网络。

- D类地址：224.0.0.0 ~ 239.255.255.255。该类IP地址最前面为“1110”，即前八位最小值为224，最大值为239。一般用于多路广播用户。
- E类地址：240.0.0.0 ~ 247.255.255.255

我们可以发现，A、B、C、D类地址的网络号所占比特位逐渐增加，而主机号所占的比特位在逐渐减少。这就意味着上述四类地址中，一类地址中的子网数量越来越多，但是子网中可以连接的主机变得越来越少。

以国内一所普通高校为例，全校师生大约3万人，如果每个人都有一台笔记本电脑需要连接到校园局域网中，有些同学还会有一些平板电脑等其他需要连接网络的终端设备，那么在申请网络时就应该以5~6万个IP地址去申请，如果使用A类地址，那么主机号24位会产生2 ^ 24 = 16777216个IP地址，远远超过实际所需要的，如果使用C类地址，则只有2 ^ 8 = 256个IP地址，远少于所需IP地址，所以最合适的是B类地址，有2 ^ 16 = 65536个IP地址。这个例子也告诉我们，IP地址不能太多，会造成大量浪费；也不能太少，否则很多设备会无法连接网络。

#### 广播地址

- 广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。
- 广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。

这个广播地址可以给同一个链路中互相连接的所有主机发送数据包。

#### IP多播

- 多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。
- 相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。

多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。

此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。

#### 子网掩码

随着Internet的发展，使用前四位是否为1来分类的方案弊端开始显现：那就是很多子网的申请者都会去申请B类网络地址，因为A类根本用不完，而C类不够用。导致B类的网络地址很快就被分配完了。而申请了A类的网络又会浪费大量的IP地址。在这种情况下，**人们提出了新的划分方案：CIDR（Classless Interdomain Routing无类型域间选路）**

- 引入子网掩码来区分网络号和主机号
- 子网掩码也是一个32位的正整数，但结尾通常是一串0
- 将IP地址与子网掩码进行`&`操作，所得结果就是网络号
- 网络号和主机号的划分就与这个IP地址是A类、B类还是C类无关了

举两个例子帮助理解通过子网掩码来划分网络号和主机号

|    IP地址     |               二进制表达                |
| :-----------: | :-------------------------------------: |
| 140.252.20.68 | 1000 1100 1111 1100 0001 0100 0100 0100 |

|   子网掩码    |               二进制表达                |
| :-----------: | :-------------------------------------: |
| 255.255.255.0 | 1111 1111 1111 1111 1111 1111 0000 0000 |

将IP地址与子网掩码进行按位与操作后得到`1000 1100 1111 1100 0001 0100 0000 0000`，再转化为方便人们使用的点分十进制为`140.252.20.0`，这就是该子网的网络号了。并且它的子网掩码末尾的8个比特位为0，这个子网可以表示2 ^ 8 = 256台主机，因此这个子网的地址范围是`140.252.20.0 ~ 140.252.20.255`。

|      IP地址      |               二进制表达                |
| :--------------: | :-------------------------------------: |
| 140. 252. 20. 68 | 1000 1100 1111 1100 0001 0100 0100 0100 |

|    子网掩码     |               二进制表达                |
| :-------------: | :-------------------------------------: |
| 255.255.255.240 | 1111 1111 1111 1111 1111 1111 1111 0000 |

将IP地址与子网掩码进行按位与操作后得到`1000 1100 1111 1100 0001 0110 0100 0000`，即该子网的网络号，同样转换成常用的点分十进制为`140.252.20.64`，它的子网掩码末尾的4个比特位为0，这个子网可以表示2 ^ 4 = 16台主机，因此这个子网的地址范围就是`140.252.20.64 ~ 140.252.20.79`。

知道“子网掩码”，我们就能判断，任意两个IP地址是否处于同一个子网络，方法是将两个IP地址与子网掩码分别进行AND运算，结果相同则说明在同一个子网络中。这是因为将IP地址与子网掩码进行`&`操作，所得结果就是网络号，网络号相同就是在同一个子网络。

例如：已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0。

|   IP地址    |               二进制表达                |
| :---------: | :-------------------------------------: |
| 172.16.10.1 | 1010 1100 0001 0000 0000 1010 0000 0001 |

|   子网掩码    |               二进制表达                |
| :-----------: | :-------------------------------------: |
| 255.255.255.0 | 1111 1111 1111 1111 1111 1111 0000 0000 |

|   IP地址    |               二进制表达                |
| :---------: | :-------------------------------------: |
| 172.16.10.2 | 1010 1100 0001 0000 0000 1010 0000 0010 |

两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。

#### 特殊的IP地址

- 将IP地址中的主机地址全设置为0，即该局域网的网络号，这个IP地址代表这个局域网。
- 将IP地址中的主机地址全设置为1，可以变成广播地址，这个广播地址可以给同一个链路中互相连接的所有主机发送数据包
- 127.*的IP地址用于本地环回测试，通常是127.0.0.1，或者localhost。

假如某个大学要在校园内部组建一个局域网，只实现校园内部的网络通信而不与外界任何一台机器进行通信，那么理论上2 ^ 32个IP地址都可以使用，因为只在这个局域网中，不会出现相同的IP地址。不过RFC1918规定了组建局域网的私有IP地址的规范：

- 10.* 前8位是网络号，共有16,777,216个地址
- 172.16.*~172.31.* 前12位是网络号，共有1,048,576个地址
- 192.168.* 前16位是网络号，共有65,536个地址

上述范围内的IP地址都是私有IP，不在上述范围内的IP则为全局IP地址（公网IP地址）。

### 4.1.3 IP路由

发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。

当一个 IP 包从一台计算机被发送，它会到达一个 IP 路由器。IP 路由器负责将这个包路由至它的目的地，直接地或者通过其他的路由器。

在一个相同的通信中，一个包所经由的路径可能会和其他的包不同。而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址。

### 4.1.4 数据分片

数据分片也叫做IP分包。

当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也可能发生在中转路由器上，而且在传输过程中可能被多次分片，只有在最终目标机器上，这些分片才会在内核中被IP模块重新组装。IP头部中的数据报标识、标志、和片偏移为IP的分片和重组提供了足够的信息。

MTU（Maximum Transmission Unit最大传输单元）是在IP层下面的MAC协议中的概念，MAC协议我们可以理解为是物理层的一些协议，它位于IP协议的下层。

那么在发送数据时相当于是`用户数据 + 应用层协议报头（如HTTP请求报头）`作为有效载荷交给传输层（如TCP协议），TCP协议再将`TCP报头 + 应用层传来的数据`下交给IP层，IP层再将`IP协议首部 + TCP层传来的TCP报文`交付给MAC帧。因此每个MAC帧其实是`IP协议首部 + IP层的有效载荷`。而MAC帧是有长度限制的，所以就要求IP数据报向下交付时并不是随心所欲想发多长就发多长，如果MAC帧要求MTU为1500字节，而IP数据包总长度有2000字节，那么就需要分片，将原有的IP数据包分成两片，依次发送，对端的主机在接收后，由对端的IP层再完成组装。

> 我们在Linux环境下可以使用ifconfig命令查看到MTU。

分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。

为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。

进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。

### 4.1.5 IPv6

IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。

IPv6的特点：

- IP 得知的扩大与路由控制表的聚合。
- 性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。
- 支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。
- 采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。
- 多播、Mobile IP 成为扩展功能。

## 4.2 ARP/RARP

只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。

ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。

- APR协议：解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。ARP是在仅知道主机的IP地址时确定其物理地址的协议。广播的方式发送数据包，获取目标主机的mac地址。

- RARP协议：解决同一个局域网上的主机或路由器的硬件地址和IP地址的映射问题。将MAC物理地址转换成IP地址。将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。


## 4.3 ICMP

ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。

IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。
