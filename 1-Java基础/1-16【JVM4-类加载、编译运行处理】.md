Java文件运行流程如下：编写 -> 编译 -> 运行。编写一个HelloWorld文件，然后使用命令将其编译为.class字节码文件，最后运行它。

JVM 想要执行这个 .class 文件，需要调用类加载器来加载它，它就像一个搬运工一样，会把所有的 .class 文件全部搬进 JVM 里面，并将这些内容转换成方法区中的运行时数据结构。ClassLoader 只负责 class 文件的加载，而是否能够运行则由 Execution Engine 来决定。

从类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中验证，准备，解析三个部分统称为连接/链接。

# 第一章 类加载阶段

Class 文件需要加载到虚拟机中之后才能运行和使用，系统加载 Class 类型的文件主要三步：加载->连接->初始化。连接过程又可分为三步：验证->准备->解析。所以类加载阶段一共有六个步骤：加载 -> 验证 -> 准备 -> 解析 -> 初始化 。再加上使用和类卸载那么类的声明周期就一共有七个阶段了：加载，验证，准备，解析，初始化，使用，卸载。

类加载完成后会在方法区内保存类的字节码二进制数据，在堆区中保存类的Class对象。方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

## 1.1 加载阶段

加载这一步主要是通过类加载器完成。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 双亲委派模型 决定（不过，我们也能打破由双亲委派模型）。该阶段主要完成下面 3 件事情：

1. 通过全类名获取定义此类的二进制字节流（可以从`ZIP`、`JAR`、`EAR`、`WAR` 、网络、动态代理技术运行时动态生成、其他文件`JSP`生成）
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。
3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口。

将类的字节码载入方法区（JDK1.7之前由永久代实现，JDK1.8后为元空间实现，在本地内存中）中，内部采用 C++ 的 `instanceKlass` 描述 java 类，它的 ﬁeld 有：

| C++描述Java类字段 | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| _java_mirror      | 类对象/镜像类。对 String 来说，镜像类是 String.class，作用是把 klass 暴露给 java 使用 |
| _super            | 父类。如果这个类还有父类没有加载，先加载父类。               |
| _ﬁelds            | 成员变量                                                     |
| _methods          | 方法                                                         |
| _constants        | 常量池                                                       |
| _class_loader     | 类加载器，每个 Java 类都有一个引用指向加载它的 `ClassLoader` |
| _vtable           | 虚方法表                                                     |
| _itable           | 接口方法                                                     |

- instanceKlass保存在方法区。JDK 8以后，方法区由元空间实现。
- instanceKlass在方法区加载的同时，会在堆内存中生成一个_java_mirror的镜像文件，俗称的**类对象**。
- InstanceKlass和类对象互相保存了对方的地址
- 类的实例对象在对象头中保存了*.class（类对象）的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息。

<img src="..\图片\1-16【JVM4-类加载、编译运行处理】\1-1.png" />

加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。所以说加载和链接可能是交替运行的。

## 1.2 连接/链接阶段

将类的二进制数据合并到JRE中。

### 1.2.1 验证

这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。验证类是否符合 JVM规范，安全性检查。

验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的，但很有必要，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。不过，验证阶段也不是必须要执行的阶段。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 `-Xverify:none` 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

验证阶段主要由四个检验阶段组成：

1. 文件格式验证（Class 文件格式检查）。验证字节流是否符合Class文件格式的规范，例如魔数是否是 ca fe ba be、主版本号是否在当前虚拟机处理范围之内、常量池中常量是否有不被支持的类型。
2. 元数据验证（字节码语义检查）。这个阶段是对字节码描述的信息进行语义分析，以保证起描述的信息符合java语言规范要求。
3. 字节码验证（程序语义检查）。进行数据流和控制流分析，这个阶段对类的方法体进行校验分析，这个阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。
4. 符号引用验证（类的正确性检查）。符号引用中通过字符串描述的全限定名是否能找到对应的类、符号引用类中的类，字段和方法的访问性(private、protected、public、default)是否可被当前类访问。

文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。

> 方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常，比如：

- `IllegalAccessError`：当类试图访问或修改它没有权限访问的方法或者字段时，抛出该异常。
- `NoSuchFieldError`：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。
- `NoSuchMethodError`：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。

### 1.2.2 准备

JVM在准备阶段为类 static 静态变量在方法区（根据版本）分配空间以及设置默认值。

* 进行内存分配的仅包括类变量（ Class Variables ，即静态变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
* Static变量在分配空间和赋值是在两个阶段完成的，分配内存空间以及设置默认值在准备阶段完成，赋值在初始化阶段完成。
* 如果 Static 变量是 ﬁnal 修饰的常量或者字符串常量，那么编译阶段值就会被确定，赋值会在准备阶段完成。
* 如果 Static 变量是 ﬁnal 的，但属于引用类型，那么赋值会在初始化阶段完成。

类变量所使用的内存都应当在方法区（JDK1.7永久代实现，JDK1.8元空间实现）中进行分配。JDK 7 之前，JVM使用永久代实现方法区完全符合这种概念。 而在 JDK 7 及之后，JVM把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。

所以 Static 变量在JDK 7以前是存储与`instanceKlass`末尾。但在JDK 7及以后就存储在`_java_mirror`末尾了

<img src="..\图片\1-16【JVM4-类加载、编译运行处理】\1-2方法区.png" />

<img src="..\图片\1-16【JVM4-类加载、编译运行处理】\1-1.png" />

| 数据类型  | 设置初值 | 数据类型 | 初始值   |
| --------- | -------- | -------- | -------- |
| byte      | (byte)0  | float    | 0.0f     |
| short     | (short)0 | double   | 0.0d     |
| int       | 0        | char     | '\u0000' |
| long      | 0L       | boolean  | false    |
| reference | null     |          |          |

### 1.2.3 解析

解析阶段是虚拟机将常量池内的符号引用解析为直接引用的过程。

符号引用就是一个类（接口、方法、字段等）中引入了其他的类，可是JVM并不知道引入的其他类在哪里，所以就用唯一符号来代替，等到类加载器去解析的时候，就通过符号引用找到那个引用类的地址，这个地址也就是直接引用。常见的符号引用包括类符号引用、接口符号引用、方法符号引用、字段符号引用。

```java
public class Demo01 {
    public static void main(String[] args) throws ClassNotFoundException, IOException {
        ClassLoader classloader = Demo01.class.getClassLoader();
        // loadClass 方法不会导致类的解析和初始化
        Class<?> c = classloader.loadClass("com.linxuan.demo03.C");
        // new C();
        // 阻塞主线程
        System.in.read();
    }
}

class C {
    D d = new D();
}

class D {
}
```

未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中。接下来借助HSDB工具查看一下：

```sh
# 使用jps命令查看进程ID 
C:\Windows\System32>jps
13488 Demo01
4964 Jps

# 切换到JDK的家目录
C:\Windows\System32>e:
E:\> cd E:\Java\jdk1.8.0_144\bin

# 在jdk\bin目录打开HSDB。在bin目录指定使用的Java版本为jdk1.8，否则使用的是配置的JAVA_HOME版本
E:\JAVA\jdk1.8.0_144\bin> java -cp ..\lib\sa-jdi.jar sun.jvm.hotspot.HSDB

# cmd窗口阻塞并打开了HSDB工具，如果打开出错，那么将jdk\jre\bin\sawindbg.dll复制到jre.1.8.0_144\bin下面
# 打开之后File -> Attach to HotSpot process输入进程ID，进程被连接上了
```

输入进程ID，打开`Tools->Class Brwser`，可以看到此时只加载了类C。

<img src="..\图片\1-16【JVM4-类加载、编译运行处理】\1-3.png" />

点击类C，查看类C的常量池，可以看到类D未被解析，只是存在于常量池中的符号：

<img src="..\图片\1-16【JVM4-类加载、编译运行处理】\1-4.png" />

这时候让D解析：

```java
public class Demo01 {
    public static void main(String[] args) throws ClassNotFoundException, IOException {
        // ClassLoader classloader = Demo01.class.getClassLoader();
        // loadClass 方法不会导致类的解析和初始化
        // Class<?> c = classloader.loadClass("com.linxuan.demo03.C");
        new C();
        // 阻塞主线程
        System.in.read();
    }
}

class C {
    D d = new D();
}

class D {
}
```

解析以后，会将常量池中的符号引用解析为直接引用。可以看到，此时已加载并解析了类C和类D。

<img src="..\图片\1-16【JVM4-类加载、编译运行处理】\1-5.png" />

## 1.3 初始化阶段

初始化阶段就是执行类构造器`clinit()`方法的过程，这一步 JVM 才开始真正执行类中定义的 Java 程序代码。`clinit()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（`static{}`块）中的语句合并产生的。虚拟机会保证这个类的『构造方法』的线程安全，加锁。

```java
public class Load4 {
    public static void main(String[] args) {
        System.out.println(E.a);
        System.out.println(E.b);
        System.out.println(E.c);
    }
}
class E {
    // 准备阶段为静态变量在方法区分配空间以及设置默认值。
    // 但是static final修饰的基本类型以及常量在编译阶段值就被确定了，准备阶段直接进行赋值，不会设置默认值
    // 所以这两个在链接-准备阶段就会赋值完毕，不会导致类的初始化。
    public static final int a = 10;
    public static final String b = "hello";
    // 包装类型，导致初始化
    public static final Integer c = 20;
    
    // 验证初始化就是看看static静态代码块是否会被执行，很显然会被执行。打印E.c之前会初始化类，打印语句。
    staic {
        System.out.println("初始化了");
    }
}
```

类的初始化是懒惰的，以下情况会初始化：

* 主方法（main方法）所在的类首先被初始化。
* 遇到`new`、`getstatic`、`putstatic`或`invokestatic` 这 4 条字节码指令时，会进行初始化。也就是new对象、访问该类静态变量或者静态方法就会将该类进行初始化。
  - 当 jvm 执行 `new` 指令时会初始化类。即当程序创建一个类的实例对象。
  - 当 jvm 执行 `getstatic` 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。
  - 当 jvm 执行 `putstatic` 指令时会初始化类。即程序给类的静态变量赋值。
  - 当 jvm 执行 `invokestatic` 指令时会初始化类。即程序调用类的静态方法。
* 使用 `java.lang.reflect` 包的方法对类进行反射调用时如 `Class.forname("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。
* 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。

以下情况不会初始化

- 访问类的 static ﬁnal 静态常量（基本类型和字符串）
- 类对象.class 不会触发初始化
- 创建该类对象的数组
- 类加载器的.loadClass方法
- Class.forNamed的参数2为false时

**验证类是否被初始化，可以看该类的静态代码块是否被执行**

```java
class A {
    static int a = 0;
    static {
        System.out.println("a init");
    }
}
class B extends A {
    static final double b = 5.0;
    static boolean c = false;
    static {
        System.out.println("b init");
    }
}
```

```java
// 验证（实验时请先全部注释，每次只执行其中一个）
public class Load3 {
    static {
        System.out.println("main init");
    }

    public static void main(String[] args) throws ClassNotFoundException {
        // 1. 静态常量（基本类型和字符串）不会触发初始化
        System.out.println(B.b);
        // 2. 类对象.class 不会触发初始化
        System.out.println(B.class);
        // 3. 创建该类的数组不会触发初始化
        System.out.println(new B[0]);
        // 4. 不会初始化类 B，但会加载 B、A
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        cl.loadClass("com.linxuan.jvm.t3.B");
        // 5. 不会初始化类 B，但会加载 B、A
        ClassLoader c2 = Thread.currentThread().getContextClassLoader();
        Class.forName("com.linxuan.jvm.t3.B", false, c2);

        // 1. 首次访问这个类的静态变量或静态方法时
        System.out.println(A.a);
        // 2. 子类初始化，如果父类还没初始化，会引发
        System.out.println(B.c);
        // 3. 子类访问父类静态变量，只触发父类初始化
        System.out.println(B.a);
        // 4. 会初始化类 B，并先初始化类 A
        Class.forName("com.linxuan.jvm.t3.B");
    }
}
```

## 1.4 懒惰初始化单例模式

典型应用 - 完成懒惰初始化单例模式

```java
public class Singleton{
    public static void test() {
        System.out.println("test");
    }

    private Singleton() { }

    // 内部类中保存单例
    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
        static{
            System.out.println("lazy holder init...");
        }
    }
    // 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员
    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
```

```java
public class Demo01 {
    public static void main(String[] args) {
        Singleton.test();           // 打印 test
        Singleton.getInstance();    // 打印 lazy holder init...
    }
}
```

以上的实现特点是：

- 懒惰实例化
- 初始化时的线程安全是有保障的

## 1.5 类卸载

卸载类即该类的 Class 对象被 GC。卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例已被 GC

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，JDK 自带的 `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

# 第二章 类加载器ClassLoader

类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。 字节码可以是 Java 源程序（`.java`文件）经过 `javac` 编译得来，也可以是通过工具动态生成或者通过网络下载得来。

- 类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。
- 每个 Java 类都有一个引用指向加载它的 `ClassLoader`。
- 数组类不是通过 `ClassLoader` 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。

<img src="..\图片\1-16【JVM4-类加载、编译运行处理】\1-1.png" />

JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。

对于已经加载的类会被放在 `ClassLoader` 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。

以JDK 8为例常见的类加载器有：

| 名称                                        | 加载的类              | 说明                        |
| ------------------------------------------- | --------------------- | --------------------------- |
| Bootstrap ClassLoader（启动类加载器）       | JAVA_HOME/jre/lib     | 无法直接访问                |
| Extension ClassLoader（扩展类加载器）       | JAVA_HOME/jre/lib/ext | 上级为Bootstrap，显示为null |
| Application ClassLoader（应用程序类加载器） | classpath             | 上级为Extension             |
| 自定义类加载器                              | 自定义                | 上级为Application           |

JVM 中内置了三个重要的 `ClassLoader`：

1. `BootstrapClassLoader`(启动类加载器) ：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（`%JAVA_HOME%/lib`目录下的 `rt.jar` 、`resources.jar` 、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
2. `ExtensionClassLoader`(扩展类加载器) ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
3. `AppClassLoader`(应用程序类加载器) ：面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

```java
public class PrintClassLoaderTree {
    public static void main(String[] args) {

        ClassLoader classLoader = PrintClassLoaderTree.class.getClassLoader();

        StringBuilder split = new StringBuilder("|-- ");
        boolean needContinue = true;
        while (needContinue){
            System.out.println(split.toString() + classLoader);
            if(classLoader == null){
                needContinue = false;
            }else{
                classLoader = classLoader.getParent();
                split.insert(0, "\t");
            }
        }
    }
}
```

```apl
|-- sun.misc.Launcher$AppClassLoader@18b4aac2
    |-- sun.misc.Launcher$ExtClassLoader@53bd815b
        |-- null
```

从输出结果可以看出：

- 我们编写的 Java 类 `PrintClassLoaderTree` 的 `ClassLoader` 是`AppClassLoader`；
- `AppClassLoader`的父 `ClassLoader` 是`ExtClassLoader`；
- `ExtClassLoader`的父`ClassLoader`是`Bootstrap ClassLoader`，因此输出结果为 null。

## 2.1 自定义类加载器

当我们想要加载非 classpath 随意路径中的类文件的时候可以通过自定义类加载器来解决。

除了 `BootstrapClassLoader` 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`。如果我们要自定义自己的类加载器，很明显需要继承 `ClassLoader`抽象类。

`ClassLoader` 类有两个关键的方法：

- `protected Class loadClass(String name, boolean resolve)`：加载指定二进制名称的类，实现了双亲委派机制。`name`为类的二进制名称，`resove`如果为 true，在加载时调用`resolveClass(Class<?> c)`方法解析该类。
- `protected Class findClass(String name)`：根据类的二进制名称来查找类，默认实现是空方法。

如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass()` 方法。

```java
D:\Bprogram\java\myclasspath>javap HelloWorld.class
Compiled from "HelloWord.java"
class HelloWorld {
  HelloWorld();
  public static void main(java.lang.String[]);
}
```

```java
class MyClassLoader extends ClassLoader {

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        String path = "D:\\Bprogram\\java\\myclasspath\\" + name + ".class";

        try {
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            Files.copy(Paths.get(path), os);

            // 得到字节数组
            byte[] bytes = os.toByteArray();

            // byte[] -> *.class
            return defineClass(name, bytes, 0, bytes.length);

        } catch (IOException e) {
            e.printStackTrace();
            throw new ClassNotFoundException("类文件未找到", e);
        }
    }
}
```

```java
public class Demo01 {
    public static void main(String[] args) throws Exception {
        MyClassLoader classLoader = new MyClassLoader();
        Class<?> c1 = classLoader.loadClass("HelloWorld");
        System.out.println(c1.getClassLoader());
    }
}
// 输出信息如下：com.linxuan.demo01.MyClassLoader@42a57993
```

## 2.3 JDBC加载驱动

我们在使用 JDBC 时，都需要加载 Driver 驱动，如果不写`Class.forName("com.mysql.jdbc.Driver")`，也是可以让 `com.mysql.jdbc.Driver` 正确加载的。

让我们追踪一下源码：

```java
@Test
public void test01() {
    try {
        Class.forName("com.mysql.cj.jdbc.Driver");
    } catch (ClassNotFoundException e) {
        throw new RuntimeException(e);
    }
}
```

```java
public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    static {
        try {
            java.sql.DriverManager.registerDriver(new Driver());
        } catch (SQLException E) {
            throw new RuntimeException("Can't register driver!");
        }
    }
}
```

```java
public class DriverManager {
    // 注册驱动的集合
    private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers 
        														= new CopyOnWriteArrayList<>();
    // 初始化驱动
    static {
        loadInitialDrivers();
        println("JDBC DriverManager initialized");
    }
}
```

先不看别的，看看 DriverManager 的类加载器：

```java
System.out.println(DriverManager.class.getClassLoader());
```

打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 `JAVA_HOME/jre/lib` 下搜索类，但 `JAVA_HOME/jre/lib` 下显然没有 `mysql-connector-java-5.1.47.jar` 包。这样问题来了，在`DriverManager` 的静态代码块中，怎么能正确加载 `com.mysql.jdbc.Driver` 呢？

继续看 `loadInitialDrivers()` 方法：

```java
private static void loadInitialDrivers() {
    String drivers;
    try {
        drivers = AccessController.doPrivileged(new PrivilegedAction<String> () {
            public String run() {
                return System.getProperty("jdbc.drivers");
            }
        });
    } catch (Exception ex) {
        drivers = null;
    }
    // 1）使用 ServiceLoader 机制加载驱动，即 SPI
    AccessController.doPrivileged(new PrivilegedAction<Void>() {
        public Void run() {
            ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
            Iterator<Driver> driversIterator = loadedDrivers.iterator();
            try{
                while(driversIterator.hasNext()) {
                    driversIterator.next();
                }
            } catch(Throwable t) {
                // Do nothing
            }
            return null;
        }
    });
    println("DriverManager.initialize: jdbc.drivers = " + drivers);
    // 2）使用 jdbc.drivers 定义的驱动名加载驱动
    if (drivers == null || drivers.equals("")) {
        return;
    }
    String[] driversList = drivers.split(":");
    println("number of Drivers:" + driversList.length);
    for (String aDriver : driversList) {
        try {
            println("DriverManager.Initialize: loading " + aDriver);
            // 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器
            Class.forName(aDriver, true, ClassLoader.getSystemClassLoader());
        } catch (Exception ex) {
            println("DriverManager.Initialize: load failed: " + ex);
        }
    }
}

```

它最后是使用 `Class.forName` 完成类的加载和初始化，关联的是应用程序类加载器，因此可以顺利完成类加载。

SPI(Service Provider Interface)：一个服务(Service)通常指的是已知的接口或者抽象类（SPI并没有强制要求服务必须是interface或abstract class，完全可以将class注册为SPI注册服务）。服务提供方就是对这个接口或者抽象类的实现，按照SPI 标准在 jar 包的 META-INF/services 包下，以接口全限定名名为文件，文件内容是实现类名称。将服务的提供代码打包成jar，放到classpath下；

SPI底层原理：使用懒加载的方式，在运行时将该服务接口的实现类通过Class.forName的方式加载到JVM中，并做实例初始化。

这样就可以使用

```java
ServiceLoader<接口类型> allImpls = ServiceLoader.load(接口类型.class);
Iterator<接口类型> iter = allImpls.iterator();
while(iter.hasNext()) {
    iter.next();
}
```

来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想：JDBC、Servlet 初始化器、Spring 容器、Dubbo（对 SPI 进行了扩展）。

接着看 `ServiceLoader.load` 方法：

```java
public static <S> ServiceLoader<S> load(Class<S> service) {
    // 获取线程上下文类加载器/应用程序类加载器
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}
```

线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类 LazyIterator 中：

```java
private S nextService() {
    if (!hasNextService())
        throw new NoSuchElementException();
    String cn = nextName;
    nextName = null;
    Class<?> c = null;
    try {
        c = Class.forName(cn, false, loader);
    } catch (ClassNotFoundException x) {
        fail(service, "Provider " + cn + " not found");
    }
    if (!service.isAssignableFrom(c)) {
        fail(service,
             "Provider " + cn + " not a subtype");
    }
    try {
        S p = service.cast(c.newInstance());
        providers.put(cn, p);
        return p;
    } catch (Throwable x) {
        fail(service,
             "Provider " + cn + " could not be instantiated",
             x);
    }
    throw new Error(); // This cannot happen
}
```

## 2.5 双亲委派模型

当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。双亲委派模型，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则。

- `ClassLoader` 类使用委托模型来搜索类和资源。
- 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
- `ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。在面向对象编程中，有一条非常经典的设计原则： 组合优于继承，多用组合少用继承。

双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 `java.lang.ClassLoader` 的 `loadClass()` ：

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 1. 检查该类是否已经加载
        Class<?> c = findLoadedClass(name);
        // 如果 c 为 null，则说明该类没有被加载过
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    // 2. 有上级的话，委派上级 loadClass
                    c = parent.loadClass(name, false);
                } else {
                    // 3. 如果没有上级了（ExtClassLoader），则委派BootstrapClassLoader
                    BootstrapClassLoader c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
            }
            // 父类加载器无法加载时，调用findClass方法加载类
            if (c == null) {
                long t1 = System.nanoTime();
                // 4. 每一层找不到，调用 findClass 方法（每个类加载器自己扩展）来加载
                c = findClass(name);
                // 5. 记录耗时
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

```java
public class Demo01 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class<?> testClass = Demo01.class.getClassLoader().loadClass("com.linxuan.demo03.Test");
        System.out.println(testClass.getClassLoader());
    }
}
```

每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

1. `sun.misc.Launcher$AppClassLoader` //1 处， 开始查看已加载的类，结果没有
2. `sun.misc.Launcher$AppClassLoader` // 2 处，委派上级`sun.misc.Launcher$ExtClassLoader.loadClass()`
3. `sun.misc.Launcher$ExtClassLoader` // 1 处，查看已加载的类，结果没有
4. `sun.misc.Launcher$ExtClassLoader` // 3 处，没有上级了，则委派 `BootstrapClassLoader`查找
5. `BootstrapClassLoader` 是在 `JAVA_HOME/jre/lib` 下找 H 这个类，显然没有
6. `sun.misc.Launcher$ExtClassLoader` // 4 处，调用自己的 findClass 方法，是在`JAVA_HOME/jre/lib/ext` 下找 H 这个类，显然没有，回到 `sun.misc.Launcher$AppClassLoader`的 // 2 处
7. 继续执行到 `sun.misc.Launcher$AppClassLoader` // 4 处，调用它自己的 findClass 方法，在classpath 下查找，找到了

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。

如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现两个不同的 `Object` 类。双亲委派模型可以保证加载的是 JRE 里的那个 `Object` 类，而不是你写的 `Object` 类。这是因为 `AppClassLoader` 在加载你的 `Object` 类时，会委托给 `ExtClassLoader` 去加载，而 `ExtClassLoader` 又会委托给 `BootstrapClassLoader`，`BootstrapClassLoader` 发现自己已经加载过了 `Object` 类，会直接返回，不会去加载你写的 `Object` 类。

## 2.6 打破双亲委派模型

重写 `loadClass()` 方法打破双亲委派模型。类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。所以想要打破双亲委派模型只需要重写`loadClass()`方法即可。

 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 `WebAppClassLoader` 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。

# 第三章 编译期处理-语法糖

所谓的语法糖 ，其实就是指 java 编译器把 *.java 源码编译为 \*.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利。

注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。

## 3.1 默认构造函数

```java
public class Candy1 {
}
```

经过编译期优化后

```java
public class Candy1 {
   // 这个无参构造器是java编译器帮我们加上的
   public Candy1() {
      // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object." <init>":()V
      super();
   }
}
```

## 3.2 自动拆装箱

基本类型和其包装类型的相互转换过程，称为拆装箱。

这个特性是 `JDK 5` 开始加入的：

```java
public class Demo2 {
   public static void main(String[] args) {
      Integer x = 1;
      int y = x;
   }
}
```

这段代码在 `JDK 5` 之前是无法编译通过的，必须改写为 :

```java
public class Demo2 {
   public static void main(String[] args) {
      // 基本类型赋值给包装类型，称为装箱
      Integer x = Integer.valueOf(1);
      // 包装类型赋值给基本类型，称谓拆箱
      int y = x.intValue();
   }
}
```

显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是包装类型），因此这些转换的事情在 `JDK 5` 以后都由编译器在编译阶段完成。即 `代码片段1` 都会在编译阶段被转换为 `代码片段2`。

## 3.3 泛型擦除和反射

泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 `泛型擦除` 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：

```java
public class Demo01 {
   public static void main(String[] args) {
      List<Integer> list = new ArrayList<>();
      list.add(10);
      Integer x = list.get(0);
   }
}
```

```java
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: new           #16           // class java/util/ArrayList
         3: dup
         4: invokespecial #18           // Method java/util/ArrayList."<init>":()V
         7: astore_1
         8: aload_1
         9: bipush        10
        11: invokestatic  #19           // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;   
        14: invokeinterface #25,  2     // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z   
        19: pop
        20: aload_1
        21: iconst_0
        22: invokeinterface #31,  2      // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object; 
        27: checkcast     #20            // class java/lang/Integer
        30: astore_2
        31: return
```

所以调用get函数取值时，有一个类型转换的操作

```java
Integer x = (Integer) list.get(0);
```

如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：

```java
// 需要将 Object 转为 Integer, 并执行拆箱操作
int x = ((Integer)list.get(0)).intValue();
```

当然JDK5以后这些我们都不用来做。

擦除的是字节码上的泛型信息，可以看到 `LocalVariableTypeTable` 仍然保留了方法参数泛型的信息：

```java
      LocalVariableTypeTable:
        Start  Length  Slot  Name   Signature
            8      24     1  list   Ljava/util/List<Ljava/lang/Integer;>;
```

局部变量的泛型信息虽然没有被擦除，但是我们也没有办法使用反射来拿到。只有在方法的参数和返回值上面才可以拿到：

```java
public Set<Integer> test(List<String> list, Map<Integer, Object> map) {
}
```

```java
Method test = Candy3.class.getMethod("test", List.class, Map.class);
Type[] types = test.getGenericParameterTypes();
for (Type type : types) {
    if (type instanceof ParameterizedType) {
        ParameterizedType parameterizedType = (ParameterizedType) type;
        System.out.println("原始类型 - " + parameterizedType.getRawType());
        Type[] arguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < arguments.length; i++) {
            System.out.printf("泛型参数[%d] - %s\n", i, arguments[i]);
        }
    }
}
```

```apl
# 打印结果如下：
原始类型 - interface java.util.List
泛型参数[0] - class java.lang.String
原始类型 - interface java.util.Map
泛型参数[0] - class java.lang.Integer
泛型参数[1] - class java.lang.Object
```

## 3.4 可变参数

```java
public class Demo04 {
    public static void foo(String... args) {
        String[] arr = args;
        System.out.println(arr.length);
    }

    public static void main(String[] args) {
        foo("hello", "world");
    }
}
```

可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同样 java 编译器会在编译期间将上述代码变换为：

```java
public class Demo04 {
    public static void foo(String[] args) {
        String[] array = args; // 直接赋值
        System.out.println(array);
    }
    public static void main(String[] args) {
        foo(new String[]{"hello", "world"});
    }
}
```

注意，如果调用的是`foo()`，即未传递参数时，等价代码为`foo(new String[]{})`，创建了一个空数组，而不是直接传递的null。

## 3.5 foreach循环

仍是 `JDK 5` 开始引入的语法糖，数组的循环：

```java
public class Demo05 {
	public static void main(String[] args) {
		int[] arr = {1, 2, 3, 4, 5};		//数组赋初值的简化写法也是一种语法糖。
		for(int x : arr) {
			System.out.println(x);
		}
	}
}
```

编译器会帮我们转换为

```java
public class Demo05 {
    public Demo05 {}

	public static void main(String[] args) {
		int[] arr = new int[]{1, 2, 3, 4, 5};
		for(int i = 0; i < arr.length; ++i) {
			int x = arr[i];
			System.out.println(x);
		}
	}
}
```

如果是集合循环：

```java
public class Demo05 {
   public static void main(String[] args) {
      List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
      for (Integer x : list) {
         System.out.println(x);
      }
   }
}
```

实际被编译器转换为对迭代器的调用：

```java
public class Demo05 {
    public Demo05 {}
    
   public static void main(String[] args) {
      List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
      Iterator<Integer> iterator = list.iterator();			//获得该集合的迭代器
      while(iterator.hasNext()) {
         Integer x = iterator.next();
         System.out.println(x);
      }
   }
}
```

> foreach 循环写法，能够配合数组，以及所有实现了 Iterable 接口的集合类一起使用，其中 Iterable 用来获取集合的迭代器（ Iterator ）

## 3.6 switch字符串

从 `JDK 7` 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：

```java
public class Demo06 {
   public static void main(String[] args) {
      String str = "hello";
      switch (str) {
         case "hello" :
            System.out.println("h");
            break;
         case "world" :
            System.out.println("w");
            break;
         default:
            break;
      }
   }
}
```

> switch 配合 String 和枚举使用时，变量不能为null。

在编译器中执行的操作：

```java
public class Demo06 {
   public Demo06() {
      
   }
   public static void main(String[] args) {
      String str = "hello";
      int x = -1;
      
      switch (str.hashCode()) {
         case 99162322 :
            if(str.equals("hello")) {	// 再次比较，因为字符串的hashCode有可能相等
               x = 0;
            }
            break;
         case 11331880 :
            if(str.equals("world")) {
               x = 1;
            }
            break;
         default:
            break;
      }

      // 用第二个switch在进行输出判断
      switch (x) {
         case 0:
            System.out.println("h");
            break;
         case 1:
            System.out.println("w");
            break;
         default:
            break;
      }
   }
}
```

在编译期间，单个的switch被分为了两个：
- 第一个用来匹配字符串，并给x赋值。字符串的匹配用到了字符串的hashCode，还用到了equals方法。使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突。
- 第二个用来根据x的值来决定输出语句

## 3.7 switch枚举

```java
enum SEX {
   MALE, FEMALE;
}
```

```java
public class Demo07 {
    public static void main(String[] args) {
        SEX sex = SEX.MALE;
        switch (sex) {
            case MALE:
                System.out.println("man");
                break;
            case FEMALE:
                System.out.println("woman");
                break;
            default:
                break;
        }
    }
}
```

编译器中执行的代码如下

```java
public class Demo07 {
    /**     
    * 定义一个合成类（仅 jvm 使用，对我们不可见）     
    * 用来映射枚举的 ordinal 与数组元素的关系     
    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     
    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     
    */ 
    static class $MAP {
        //数组大小即为枚举元素个数，里面存放了case用于比较的数字
        static int[] map = new int[2];
        static {
            //ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1
            map[SEX.MALE.ordinal()] = 1;
            map[SEX.FEMALE.ordinal()] = 2;
        }
    }

    public static void main(String[] args) {
        SEX sex = SEX.MALE;
        //将对应位置枚举元素的值赋给x，用于case操作
        int x = $MAP.map[sex.ordinal()];
        switch (x) {
            case 1:
                System.out.println("man");
                break;
            case 2:
                System.out.println("woman");
                break;
            default:
                break;
        }
    }
}
```

## 3.8 枚举类

`JDK 7` 新增了枚举类，以前面的性别枚举为例：

```java
enum SEX {
    MALE, FEMALE;
}
```

转换后的代码

```java
public final class Sex extends Enum<Sex> {   
    //对应枚举类中的元素
    public static final Sex MALE;    
    public static final Sex FEMALE;    
    private static final Sex[] $VALUES;

    static {       
        //调用构造函数，传入枚举元素的值及ordinal
        MALE = new Sex("MALE", 0);    
        FEMALE = new Sex("FEMALE", 1);   
        $VALUES = new Sex[]{MALE, FEMALE}; 
    }

    //调用父类中的方法
    private Sex(String name, int ordinal) {     
        super(name, ordinal);    
    }

    public static Sex[] values() {  
        return $VALUES.clone();  
    }
    public static Sex valueOf(String name) { 
        return Enum.valueOf(Sex.class, name);  
    } 

}
```

## 3.9 try-with-resources

`JDK 7` 开始新增了对需要关闭的资源处理的特殊语法 `try-with-resources`：

```java
try(资源变量 = 创建资源对象){
    
} catch( ) {
    
}
```

其中资源对象需要实现 `AutoCloseable` 接口，例如 `InputStream` 、 `OutputStream` 、`Connection` 、 `Statement` 、 `ResultSet` 等接口都实现了 `AutoCloseable` ，使用 `try-withresources` 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：

```java
public class Demo01 {
    public static void main(String[] args) {
        try(InputStream is = new FileInputStream("d:\\1.txt")) {
            System.out.println(is);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

会被转换为：

```java
public class Demo01 {
    public Demo01() {
    }

    public static void main(String[] args) {
        try {
            InputStream is = new FileInputStream("d:\\1.txt");
            Throwable t = null;
            try {
                System.out.println(is);
            } catch (Throwable e1) {
                // t 是我们代码出现的异常
                t = e1;
                throw e1;
            } finally {
                // 判断了资源不为空
                if (is != null) {
                    // 如果我们代码有异常
                    if (t != null) {
                        try {
                            is.close();
                        } catch (Throwable e2) {
                            // 如果 close 出现异常，作为被压制异常添加
                            t.addSuppressed(e2);
                        }
                    } else {
                        // 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e
                        is.close();
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

为什么要设计一个 `addSuppressed(Throwable e)` （添加被压制异常）的方法呢？是为了防止异常信息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）：

```java
public class Test6 {
    public static void main(String[] args) {
        try (MyResource resource = new MyResource()) {
            int i = 1/0;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
class MyResource implements AutoCloseable {
    public void close() throws Exception {
        throw new Exception("close 异常");
    }
}
```

输出：

```apl
java.lang.ArithmeticException: / by zero
    at test.Test6.main(Test6.java:7)
    Suppressed: java.lang.Exception: close 异常
        at test.MyResource.close(Test6.java:18)
        at test.Test6.main(Test6.java:6)
```

如以上代码所示，两个异常信息都不会丢。

## 3.10 方法重写时的桥接方法

我们都知道，方法重写时对返回值分两种情况：

- 父子类的返回值完全一致

- 子类返回值是父类返回值的子类

  ```java
  class A {
      public Number m() {
          return 1;
      }
  }
  ```

  ```java
  class B extends A {
      @Override
      // 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类
      public Integer m() {
          return 2;
      }
  }
  ```

对于子类，java 编译器会做如下处理：

```java
class B extends A {
    public Integer m() {
        return 2;
    }
    // 此方法才是真正重写了父类 public Number m() 方法
    public synthetic bridge Number m() {
        // 调用 public Integer m()
        return m();
    }
}
```

其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 `public Integer m()` 没有命名冲突，可以用下面反射代码来验证：

```java
for (Method m : B.class.getDeclaredMethods()) {
    System.out.println(m);
}
```

会输出：

```java
public java.lang.Integer test.candy.B.m()
public java.lang.Number test.candy.B.m()
```

## 3.11 匿名内部类

```java
public class Candy11 {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("ok");
            }
        };
    }
}
```

转换后的代码

```java
// 额外生成的类
final class Candy11$1 implements Runnable {
    Candy11$1() {
    }
    public void run() {
        System.out.println("ok");
    }
}
```

```java
public class Candy11 {
    public static void main(String[] args) {
        Runnable runnable = new Candy11$1();
    }
}
```

引用局部变量的匿名内部类，源代码：

```java
public class Candy11 {
    public static void test(final int x) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("ok:" + x);
            }
        };
    }
}
```

转化后代码

```java
// 额外生成的类
final class Candy11$1 implements Runnable {
    int val$x;
    Candy11$1(int x) {
        this.val$x = x;
    }
    public void run() {
        System.out.println("ok:" + this.val$x);
    }
}
```

```java
public class Candy11 {
    public static void test(final int x) {
        Runnable runnable = new Candy11$1(x);
    }
}
```

这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 `final` 的：因为在创建 `Candy11$1` 对象时，将 `x` 的值赋值给了 `Candy11$1` 对象的 `val$x` 属性，所以 `x` 不应该再发生变化了，如果变化，那么 `val$x` 属性没有机会再跟着一起变化。

# 第四章 运行期优化

## 4.1 即时编译

### 4.1.1 分层编译

```java
public class Demo01 {
    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            long start = System.nanoTime();
            for (int j = 0; j < 1000; j++) {
                new Object();
            }
            long end = System.nanoTime();
            System.out.printf("%d\t%d\n", i, (end - start));
        }
    }
}
```

```java
0       31900
1       36700
...
62      43100		
63      14100		// 时间变短了
64      16900
...
188     19300
189     200			// 时间变短了
190     300
...
```

原因是什么呢？

JVM 将执行状态分成了 5 个层次：

- 0层：解释执行，用解释器将字节码翻译为机器码
- 1层：使用 C1 即时编译器编译执行（不带 proﬁling）
- 2层：使用 C1 即时编译器编译执行（带基本的profiling）
- 3层：使用 C1 即时编译器编译执行（带完全的profiling）
- 4层：使用 C2 即时编译器编译执行

> proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的回边次数】等

即时编译器（JIT）与解释器的区别如下：

- 解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释
- JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译
- 解释器是将字节码解释为针对所有平台都通用的机器码
- JIT 会根据平台类型，生成平台特定的机器码

对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter < C1 < C2，总的目标是发现热点代码（hotspot名称的由来），并优化这些热点代码。

### 4.1.2 逃逸分析

逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。

逃逸分析的 JVM 参数如下：开启逃逸分析`-XX:+DoEscapeAnalysis`、关闭逃逸分析`-XX:-DoEscapeAnalysis`、显示分析结果`-XX:+PrintEscapeAnalysis`。

逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数

- 全局逃逸（GlobalEscape）：一个对象的作用范围逃出了当前方法或者当前线程。例如对象是一个静态变量、对象是一个已经发生逃逸的对象、对象作为当前方法的返回值。
- 参数逃逸（ArgEscape）：即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。
- 没有逃逸：即方法中的对象没有发生逃逸

针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化：锁消除、标量替换、栈上分配。接下来详细解释一下。

**锁消除**

我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁

例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作

JMH测试一下：

```java
@Fork(1)
@BenchmarkMode(Mode.AverageTime)
@Warmup(iterations=3)
@Measurement(iterations=5)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class MyBenchmark {
    static int x = 0;
    @Benchmark
    public void a() throws Exception {
        x++;
    }
    @Benchmark
    public void b() throws Exception {
        Object o = new Object();
        synchronized (o) {
            x++;
        }
    }
}
```

`java -jar benchmarks.jar`，时间几乎没有差别。

```java
Benchmark Mode Samples Score Score error Units 
c.i.MyBenchmark.a avgt 5 1.542 0.056 ns/op 
c.i.MyBenchmark.b avgt 5 1.518 0.091 ns/op 
```

`java -XX:-EliminateLocks -jar benchmarks.jar`，时间相差16倍。

```java
Benchmark Mode Samples Score Score error Units 
c.i.MyBenchmark.a avgt 5 1.507 0.108 ns/op 
c.i.MyBenchmark.b avgt 5 16.976 1.572 ns/op 
```

锁消除的 JVM 参数如下：开启锁消除`-XX:+EliminateLocks`、关闭锁消除`-XX:-EliminateLocks`。锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。

**标量替换**

首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如对象。对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。

这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。

标量替换的 JVM 参数如下：开启标量替换`-XX:+EliminateAllocations`、关闭标量替换`-XX:-EliminateAllocations`、显示标量替换详情`-XX:+PrintEliminateAllocations`。标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。

**栈上分配**

当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。

### 4.1.3 方法内联

内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换。如下：

```java
private static int square(final int i) {
    return i * i;
}
```

```java
System.out.println(square(9));
```

如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、 粘贴到调用者的位置：

```java
System.out.println(9 * 9);
```

接下来实验一下：

```java
public class JIT2 {
    // -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining （解锁隐藏参数）打印内联信息
    // -XX:CompileCommand=dontinline,*JIT2.square 禁止某个方法 inlining
    // -XX:+PrintCompilation 打印编译信息
    public static void main(String[] args) {
        int x = 0;
        for (int i = 0; i < 500; i++) {
            long start = System.nanoTime();
            for (int j = 0; j < 1000; j++) {
                x = square(9);
            }
            long end = System.nanoTime();
            System.out.printf("%d\t%d\t%d\n",i,x,(end - start));
        }
    }
    private static int square(final int i) {
        return i * i;
    }
}
```

C++是否为内联函数由自己决定，Java由编译器决定。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求：关键字final修饰，用来指明那个函数是希望被JVM内联的。总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数。

JVM内联有许多运行时优化。首先短方法更利于JVM推断，流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。

### 4.1.4 字段优化

JMH 基准测试请参考：http://openjdk.java.net/projects/code-tools/jmh/

创建 maven 工程，添加依赖如下

```xml
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-core</artifactId>
    <version>1.35</version>
</dependency>

<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-generator-annprocess</artifactId>
    <version>1.35</version>
    <scope>provided</scope>
</dependency>
```

```json
{
    "java.configuration.updateBuildConfiguration": "automatic", //maven、gradle的配置文件变更后自动更新
    "java.eclipse.downloadSources": true,       // 设置导入jar包下载源代码
    "java.maven.downloadSources": true,         // 设置导入jar包下载源代码
    "java.configuration.runtimes": [            // 设置运行项目jdk VSCode使用jdk9不行
        {
            "name": "JavaSE-1.8",
            "path": "E:\\JAVA\\jdk1.8.0_144",
            "default": true
        }
    ]
}
```

```java
@Warmup(iterations = 2, time = 1)
@Measurement(iterations = 5, time = 1)
@State(Scope.Benchmark)
public class Demo01 {
    int[] elements = randomInts(1_000);

    private static int[] randomInts(int size) {
        Random random = ThreadLocalRandom.current();
        int[] values = new int[size];
        for (int i = 0; i < size; i++) {
            values[i] = random.nextInt();
        }
        return values;
    }

    @Benchmark
    public void test1() {
        for (int i = 0; i < elements.length; i++) {
            doSum(elements[i]);
        }
    }

    @Benchmark
    public void test2() {
        int[] local = this.elements;
        for (int i = 0; i < local.length; i++) {
            doSum(local[i]);
        }
    }

    @Benchmark
    public void test3() {
        for (int element : elements) {
            doSum(element);
        }
    }

    static int sum = 0;

    @CompilerControl(CompilerControl.Mode.INLINE)
    static void doSum(int x) {
        sum += x;
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
        .include(Demo01.class.getSimpleName())
        .forks(1)
        .build();
        new Runner(opt).run();
    }
}
```

首先启用 doSum 的方法内联，测试结果如下（每秒吞吐量，分数越高的更好）：

```apl
Benchmark Mode Samples Score Score error Units
t.Benchmark1.test1 thrpt 5 2420286.539 390747.467 ops/s
t.Benchmark1.test2 thrpt 5 2544313.594 91304.136 ops/s
t.Benchmark1.test3 thrpt 5 2469176.697 450570.647 ops/s
```

接下来禁用 doSum 方法内联

```java
@CompilerControl(CompilerControl.Mode.DONT_INLINE)
static void doSum(int x) {
    sum += x;
}
```

测试结果如下：

```apl
Benchmark Mode Samples Score Score error Units
t.Benchmark1.test1 thrpt 5 296141.478 63649.220 ops/s
t.Benchmark1.test2 thrpt 5 371262.351 83890.984 ops/s
t.Benchmark1.test3 thrpt 5 368960.847 60163.391 ops/s
```

分析：在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化？

如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子（伪代码）：

```java
@Benchmark
public void test1() {
    // elements.length 首次读取会缓存起来 -> int[] local
    for (int i = 0; i < elements.length; i++) { // 后续 999 次 求长度 <- local
        sum += elements[i]; // 1000 次取下标 i 的元素 <- local
    }
}
```

可以节省 1999 次 Field 读取操作。但如果 doSum 方法没有内联，则不会进行上面的优化。

内联或者不内联对后两个方法没有影响：

* 自己本省就是用了数组存起来
* foreach编译期优化，语法糖也是数据。

## 4.2 反射优化

```java
package com.linxuan.jvm.t3.reflect;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Reflect1 {
    public static void foo() {
        System.out.println("foo...");
    }
    public static void main(String[] args) throws Exception {
        Method foo = Reflect1.class.getMethod("foo");
        for (int i = 0; i <= 16; i++) {
            System.out.printf("%d\t", i);
            foo.invoke(null);
        }
        System.in.read();
    }
}
```

foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现，源码如下：

```java
class NativeMethodAccessorImpl extends MethodAccessorImpl {
    private final Method method;
    private DelegatingMethodAccessorImpl parent;
    private int numInvocations;
    
    NativeMethodAccessorImpl(Method method) {
        this.method = method;
    }
    
    public Object invoke(Object target, Object[] args)
        throws IllegalArgumentException, InvocationTargetException {
        // inflationThreshold 膨胀阈值，默认 15
        if (++this.numInvocations > ReflectionFactory.inflationThreshold()
            && !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) {
            // 使用 ASM 动态生成的新实现代替本地实现，速度较本地实现快 20 倍左右
            MethodAccessorImpl generatedMethodAccessor =
                (MethodAccessorImpl)
                (new MethodAccessorGenerator())
                .generateMethod(
                this.method.getDeclaringClass(),
                this.method.getName(),
                this.method.getParameterTypes(),
                this.method.getReturnType(),
                this.method.getExceptionTypes(),
                this.method.getModifiers()
            );
            this.parent.setDelegate(generatedMethodAccessor);
        }
        // 调用本地实现
        return invoke0(this.method, target, args);
    }
    void setParent(DelegatingMethodAccessorImpl parent) {
        this.parent = parent;
    }
    private static native Object invoke0(Method method, Object target, Object[] args);
}
```

当调用到第 16 次（从0开始算）时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到 类名为 sun.reflect.GeneratedMethodAccessor1

可以使用阿里的 arthas 工具：

```apl
java -jar arthas-boot.jar
[INFO] arthas-boot version: 3.1.1
[INFO] Found existing java process, please choose one and hit RETURN.
* [1]: 13065 com.linxuan.jvm.t3.reflect.Reflect1
```

选择 1 回车表示分析该进程

```apl
1
[INFO] arthas home: /root/.arthas/lib/3.1.1/arthas
[INFO] Try to attach process 13065
[INFO] Attach process 13065 success.
[INFO] arthas-client connect 127.0.0.1 3658
,---. ,------. ,--------.,--. ,--. ,---. ,---.
/ O \ | .--. ''--. .--'| '--' | / O \ ' .-'
| .-. || '--'.' | | | .--. || .-. |`. `-.
| | | || |\ \ | | | | | || | | |.-' |
`--' `--'`--' '--' `--' `--' `--'`--' `--'`-----'
wiki https://alibaba.github.io/arthas
tutorials https://alibaba.github.io/arthas/arthas-tutorials
version 3.1.1
pid 13065
time 2019-06-10 12:23:54
```

再输入【jad + 类名】来进行反编译

```java
$ jad sun.reflect.GeneratedMethodAccessor1
    ClassLoader:
+-sun.reflect.DelegatingClassLoader@15db9742
    +-sun.misc.Launcher$AppClassLoader@4e0e2f2a
    +-sun.misc.Launcher$ExtClassLoader@2fdb006e
    Location:
/*
* Decompiled with CFR 0_132.
*
* Could not load the following classes:
* com.linxuan.jvm.t3.reflect.Reflect1
*/
package sun.reflect;
import com.linxuan.jvm.t3.reflect.Reflect1;
import java.lang.reflect.InvocationTargetException;
import sun.reflect.MethodAccessorImpl;

public class GeneratedMethodAccessor1
    extends MethodAccessorImpl {
    /*
    * Loose catch block
    * Enabled aggressive block sorting
    * Enabled unnecessary exception pruning
    * Enabled aggressive exception aggregation
    * Lifted jumps to return sites
    */
    public Object invoke(Object object, Object[] arrobject) throws
        InvocationTargetException {
        // 比较奇葩的做法，如果有参数，那么抛非法参数异常
        block4 : {
            if (arrobject == null || arrobject.length == 0) break block4;
            throw new IllegalArgumentException();
        }
        try {
            // 可以看到，已经是直接调用了😱😱😱
            Reflect1.foo();
            // 因为没有返回值
            return null;
        }
        catch (Throwable throwable) {
            throw new InvocationTargetException(throwable);
        }
        catch (ClassCastException | NullPointerException runtimeException) {
            throw new IllegalArgumentException(Object.super.toString());
        }
    }
}
Affect(row-cnt:1) cost in 1540 ms
```

通过查看 `ReflectionFactory` 源码可知

- `sun.reflect.noInflation` 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算）
- `sun.reflect.inflationThreshold` 可以修改膨胀阈值
