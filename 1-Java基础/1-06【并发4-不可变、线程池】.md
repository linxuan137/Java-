# 第六章 共享模型之不可变

## 6.1 日期转换的问题

下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
for (int i = 0; i < 10; i++) {
    new Thread(() -> {
        try {
            log.debug("{}", sdf.parse("1951-04-21"));
        } catch (Exception e) {
            log.error("{}", e);
        }
    }).start();
}
```

有很大几率出现 `java.lang.NumberFormatException` 或者出现不正确的日期解析结果，例如：

```apl
19:10:40.859 [Thread-2] c.TestDateParse - {} 
java.lang.NumberFormatException: For input string: "" 
 at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) 
 at java.lang.Long.parseLong(Long.java:601) 
 at java.lang.Long.parseLong(Long.java:631) 
 at java.text.DigitList.getLong(DigitList.java:195) 
 at java.text.DecimalFormat.parse(DecimalFormat.java:2084) 
 at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2162) 
 at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) 
 at java.text.DateFormat.parse(DateFormat.java:364) 
 at cn.itcast.n7.TestDateParse.lambda$test1$0(TestDateParse.java:18) 
 at java.lang.Thread.run(Thread.java:748) 
19:10:40.859 [Thread-1] c.TestDateParse - {} 
java.lang.NumberFormatException: empty String 
 at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1842) 
 at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110) 
 at java.lang.Double.parseDouble(Double.java:538) 
 at java.text.DigitList.getDouble(DigitList.java:169) 
 at java.text.DecimalFormat.parse(DecimalFormat.java:2089) 
 at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2162) 
 at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) 
 at java.text.DateFormat.parse(DateFormat.java:364) 
 at cn.itcast.n7.TestDateParse.lambda$test1$0(TestDateParse.java:18) 
 at java.lang.Thread.run(Thread.java:748) 
19:10:40.857 [Thread-8] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-9] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-6] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-4] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-5] c.TestDateParse - Mon Apr 21 00:00:00 CST 178960645 
19:10:40.857 [Thread-0] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-7] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-3] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
```

对此我们的解决方法有两种：加锁和使用不可变的API。

* 加锁：这样虽能解决问题，但带来的是性能上的损失，并不算很好。

  ```java
  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
  for (int i = 0; i < 50; i++) {
      new Thread(() -> {
          synchronized (sdf) {
              try {
                  log.debug("{}", sdf.parse("1951-04-21"));
              } catch (Exception e) {
                  log.error("{}", e);
              }
          }
      }).start();
  }
  ```

* 不可变：如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在 Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类`DateTimeFormatter`。

  ```java
  DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");
  
  for (int i = 0; i < 10; i++) {
      new Thread(() -> {
          log.debug("转换格式：" + dtf.parse("2018-10-01"));
          // LocalDate date = dtf.parse("2018-10-01", LocalDate::from);
          // log.debug("{}", date);
      }, "t" + i).start();
  }
  ```

  可以看 DateTimeFormatter 的文档：
  
  ```java
  @implSpec
  This class is immutable and thread-safe.
  ```
  
  不可变对象，实际是另一种避免竞争的方式。

## 6.2 String类不可变

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];

    /** Cache the hash code for the string */
    private int hash; // Default to 0

    //....
}
```

**ﬁnal 的使用**

发现该类、类中所有属性都是 ﬁnal 的

- 属性用 ﬁnal 修饰保证了该属性是只读的，不能修改
- 类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性

**保护性拷贝 **

以 substring 为例

```java
public String substring(int beginIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    int subLen = value.length - beginIndex;
    if (subLen < 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    //返回的是一个新的对象
    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
}
```

发现其内部是调用 String 的构造方法创建了一个新字符串

```java
public String(char value[], int offset, int count) {
    if (offset < 0) {
        throw new StringIndexOutOfBoundsException(offset);
    }
    if (count <= 0) {
        if (count < 0) {
            throw new StringIndexOutOfBoundsException(count);
        }
        if (offset <= value.length) {
            this.value = "".value;
            return;
        }
    }
    // Note: offset or count might be near -1>>>1.
    if (offset > value.length - count) {
        throw new StringIndexOutOfBoundsException(offset + count);
    }
    this.value = Arrays.OfRange(value, offset, offset+count);
}
```

构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive ）】。

## 6.3 享元模式

英文名称：`Flyweight pattern` 当需要重用数量有限的同一类对象时

> wikipedia： A flyweight is an object that minimizes memory usage by sharing as much data as
> possible with other similar objects

### 6.3.1 体现

在JDK中 `Boolean`，`Byte`，`Short`，`Integer`，`Long`，`Character` 等包装类提供了 `valueOf` 方法，例如 `Long` 的`valueOf` 会缓存 `-128~127` 之间的 `Long` 对象，在这个范围之间会重用对象，大于这个范围，才会新建 `Long` 对象：

```java
public static Long valueOf(long l) {
    final int offset = 128;
    if (l >= -128 && l <= 127) { // will cache
        return LongCache.cache[(int)l + offset];
    }
    return new Long(l);
}
```

- `Byte`, `Short`, `Long` 缓存的范围都是 `-128~127`。
- `Character` 缓存的范围是 `0~127`。
- `Integer`的默认范围是 `-128~127`，最小值不能变，但最大值可以通过调整虚拟机参数 ` 
  -Djava.lang.Integer.IntegerCache.high` 来改变。
- `Boolean` 缓存了 `TRUE` 和 `FALSE`。

另外`String串池`和`BigDecimal` `BigInteger`都是应用了享元模式，都是不可变的，线程安全的。

> `BigDecimal` `BigInteger`虽然是线程安全的，但是如果该类的许多方法组合到一起那么就有可能造成线程不安全了。之前在原子引用的时候涉及到了！

### 6.3.2 实现数据库连接池

一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。

> QPS ：每秒查询数

```java
class Pool {
    // 1. 连接池大小
    private final int poolSize;
    // 2. 连接对象数组
    private Connection[] connections;
    // 3. 连接状态数组 0 表示空闲， 1 表示繁忙
    private AtomicIntegerArray states;
    
    // 4. 构造方法初始化
    public Pool(int poolSize) {
        this.poolSize = poolSize;
        this.connections = new Connection[poolSize];
        this.states = new AtomicIntegerArray(new int[poolSize]);
        for (int i = 0; i < poolSize; i++) {
            connections[i] = new MockConnection();
        }
    }
    
    // 5. 借连接
    public Connection borrow() {
        while(true) {
            for (int i = 0; i < poolSize; i++) {
                // 获取空闲连接
                if(states.get(i) == 0) {
                    if (states.compareAndSet(i, 0, 1)) {
                        log.debug("borrow {}", connections[i]);
                        return connections[i];
                    }
                }
            }
            // 如果没有空闲连接，当前线程进入等待
            synchronized (this) {
                try {
                    log.debug("wait...");
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    // 6. 归还连接
    public void free(Connection conn) {
        for (int i = 0; i < poolSize; i++) {
            if (connections[i] == conn) {
                states.set(i, 0);
                synchronized (this) {
                    log.debug("free {}", conn);
                    this.notifyAll();
                }
                break;
            }
        }
    }
}

class MockConnection implements Connection {
    // 实现略
}
```

使用连接池：

```java
Pool pool = new Pool(2);
for (int i = 0; i < 5; i++) {
    new Thread(() -> {
        Connection conn = pool.borrow();
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        pool.free(conn);
    }).start();
}
```

以上实现没有考虑：

- 连接的动态增长与收缩
- 连接保活（可用性检测）
- 等待超时处理
- 分布式 hash

对于关系型数据库，有比较成熟的连接池实现，例如`c3p0`, `druid`等。对于更通用的对象池，可以考虑使用`apache commons pool`，例如redis连接池可以参考jedis中关于连接池的实现。

## 6.4 final原理

理解了 volatile 原理，再对比 final 的实现就比较简单了

```java
public class TestFinal {
    final int a = 20;
}
```

字节码

```java
public com.linxuan.demo01.Demo01();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #12                 // Method java/lang/Object."<init>":()V
         4: aload_0
         5: bipush        20
         7: putfield      #14                 // Field a:I
             // -----> 写屏障
        10: return
```

发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到 它的值时不会出现为 0 的情况。

## 6.5 无状态

在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的。

因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】

# 第七章 线程池

线程池使得线程可以复用，执行完一个任务，并不被销毁，可以继续执行其他的任务。其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。

合理利用线程池有三个好处：

* 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的损耗。
* 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能够立即执行。
* 提高线程的可管理性。线程时稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

## 7.1 自定义线程池

<img src="..\图片\1-06【并发】\12-1线程池.png" />

- 阻塞队列中维护了由主线程（或者其他线程）所产生的的任务。
- 主线程类似于生产者，产生任务并放入阻塞队列中。
- 线程池类似于消费者，得到阻塞队列中已有的任务并执行。

步骤1：自定义拒绝策略接口

```java
// 函数时接口，代表可以使用Lambda表达式
@FunctionalInterface
interface RejectPolicy<T> {
    void reject(BlockingQueue<T> queue, T task);
}
```

步骤2：自定义任务队列

```java
class BlockingQueue<T> {
    
    // 1. 任务队列/阻塞队列
    private Deque<T> queue = new ArrayDeque<>();
    // 2. 锁
    private ReentrantLock lock = new ReentrantLock();
    // 3. 生产者条件变量
    private Condition fullWaitSet = lock.newCondition();
    // 4. 消费者条件变量
    private Condition emptyWaitSet = lock.newCondition();
    // 5. 容量
    private int capcity;
    
    public BlockingQueue(int capcity) {
        this.capcity = capcity;
    }
    
    // 带超时阻塞获取
    public T poll(long timeout, TimeUnit unit) {
        lock.lock();
        try {
            // 将 timeout 统一转换为 纳秒
            long nanos = unit.toNanos(timeout);
            while (queue.isEmpty()) {
                try {
                    // 如果最后消费者等待时间超过了timeout，并且queue仍然是空的，那么直接返回null
                    if (nanos <= 0) {
                        return null;
                    }
                    // 消费者等待时间
                    nanos = emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        } 
    }
    
    // 阻塞获取，一直等待着
    public T take() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }
    
    // 阻塞添加
    public void put(T task) {
        lock.lock();
        try {
            while (queue.size() == capcity) {
                try {
                    log.debug("等待加入任务队列 {} ...", task);
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("加入任务队列 {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
        } finally {
            lock.unlock();
        }
    }
    
    // 带超时时间阻塞添加
    public boolean offer(T task, long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            long nanos = timeUnit.toNanos(timeout);
            while (queue.size() == capcity) {
                try {
                    if(nanos <= 0) {
                        return false;
                    }
                    log.debug("等待加入任务队列 {} ...", task);
                    nanos = fullWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("加入任务队列 {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }
    
    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }
    
    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            // 判断队列是否满
            if(queue.size() == capcity) {
                rejectPolicy.reject(this, task);
            } else { // 有空闲
                log.debug("加入任务队列 {}", task);
                queue.addLast(task);
                emptyWaitSet.signal();
            }
        } finally {
            lock.unlock();
        }
    }
}
```

步骤3：自定义线程池

```java
class ThreadPool {
    
    // 任务队列
    private BlockingQueue<Runnable> taskQueue;
    // 线程集合
    private HashSet<Worker> workers = new HashSet<>();
    // 核心线程数
    private int coreSize;
    // 获取任务时的超时时间
    private long timeout;
    private TimeUnit timeUnit;
    private RejectPolicy<Runnable> rejectPolicy;
    
    // 执行任务
    public void execute(Runnable task) {
        // 当任务数没有超过 coreSize 时，直接交给 worker 对象执行
        // 如果任务数超过 coreSize 时，加入任务队列暂存
        synchronized (workers) {
            if(workers.size() < coreSize) {
                Worker worker = new Worker(task);
                log.debug("新增 worker{}, {}", worker, task);
                workers.add(worker);
                worker.start();
            } else {
                // taskQueue.put(task);
                // 1) 死等
                // 2) 带超时等待
                // 3) 让调用者放弃任务执行
                // 4) 让调用者抛出异常
                // 5) 让调用者自己执行任务
                taskQueue.tryPut(rejectPolicy, task);
            }
        }
    }
    
    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapcity, 
                      RejectPolicy<Runnable> rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.taskQueue = new BlockingQueue<>(queueCapcity);
        this.rejectPolicy = rejectPolicy;
    }
    
    class Worker extends Thread{
        
        private Runnable task;
        public Worker(Runnable task) {
            this.task = task;
        }
        
        @Override
        public void run() {
            // 执行任务
            // 1) 当 task 不为空，执行任务
            // 2) 当 task 执行完毕，再接着从任务队列获取任务并执行
            // while(task != null || (task = taskQueue.take()) != null) {
            while(task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {
                try {
                    log.debug("正在执行...{}", task);
                    task.run();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    task = null;
                }
            }
            synchronized (workers) {
                log.debug("worker 被移除{}", this);
                workers.remove(this);
            }
        }
    }
}
```

步骤4：测试

```java
public static void main(String[] args) {
    ThreadPool threadPool = new ThreadPool(1, 1000, TimeUnit.MILLISECONDS, 1, (queue, task)->{
                                               // 1. 死等
                                               // queue.put(task);
                                               // 2) 带超时等待
                                               // queue.offer(task, 1500, TimeUnit.MILLISECONDS);
                                               // 3) 让调用者放弃任务执行
                                               // log.debug("放弃{}", task);
                                               // 4) 让调用者抛出异常
                                               // throw new RuntimeException("任务执行失败 " + task);
                                               // 5) 让调用者自己执行任务
                                               task.run();
                                           });
    for (int i = 0; i < 4; i++) {
        int j = i;
        threadPool.execute(() -> {
            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("{}", j);
        });
    }
}
```

实现了一个简单的线程池

- 阻塞队列`BlockingQueue`用于暂存来不及被线程执行的任务，也可以说是平衡生产者和消费者执行速度上的差异，里面的获取任务和放入任务用到了生产者消费者模式。
- 线程池中对线程Thread进行了再次的封装，封装为了Worker。在调用任务的run方法时，线程会去执行该任务，执行完毕后还会到阻塞队列中获取新任务来执行。
- 线程池中执行任务的主要方法为execute方法。执行时要判断正在执行的线程数是否大于了线程池容量。

## 7.2 创建线程池方法

线程池的创建方法总共有 7 种，但总体来说可分为 2 类：

* 一类是通过 `ThreadPoolExecutor` 创建的线程池；
* 另一个类是通过 `Executors` 创建的线程池。

ThreadPoolExecutor 最原始的创建线程池的方式，最多可以设置 7 个参数，如下代码所示：

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    // 省略...
}
```

要配置一个线程池比较复杂，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在`java.util.concurrent.Executors`线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。

线程池的创建方式如下，其中 6 种是通过 `Executors` 创建的，1 种是通过`ThreadPoolExecutor` 创建的：

1. `Executors.newFixedThreadPool`：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；
2. `Executors.newCachedThreadPool`：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；
3. `Executors.newSingleThreadExecutor`：创建单个线程数的线程池，它可以保证先进先出的执行顺序；
4. `Executors.newScheduledThreadPool`：创建一个可以执行延迟任务的线程池；
5. `Executors.newSingleThreadScheduledExecutor`：创建一个单线程的可以执行延迟任务的线程池；
6. `Executors.newWorkStealingPool`：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。
7. `ThreadPoolExecutor`：最原始的创建线程池的方式，它包含了 7 个参数可供设置。

## 7.3 ThreadPoolExecutor

java里面线程池的顶级接口是`java.util.concurrent.Executor`，但是严格意义上讲`Executor`并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是`java.util.concurrent.ExecutorService`。

<img src="..\图片\1-06【并发】\12.png" />

### 7.3.1 线程池状态

部分源码如下：

```java
public class ThreadPoolExecutor extends AbstractExecutorService {

    // 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    // 并不是所有平台的int都是32位。
    // 去掉前三位保存线程状态的位数，剩下的用于保存线程数量
    private static final int COUNT_BITS = Integer.SIZE - 3;
    // 2^COUNT_BITS次方，表示可以保存的最大线程数
    // CAPACITY 的高3位为 0
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

    // 线程池状态
    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 << COUNT_BITS;
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    private static final int STOP       =  1 << COUNT_BITS;
    private static final int TIDYING    =  2 << COUNT_BITS;
    private static final int TERMINATED =  3 << COUNT_BITS;
}
```

| 状态名称   | 高3位的值 | 描述                                          |
| ---------- | --------- | --------------------------------------------- |
| RUNNING    | 111       | 接收新任务，同时处理任务队列中的任务          |
| SHUTDOWN   | 000       | 不接受新任务，但是处理任务队列中的任务        |
| STOP       | 001       | 中断正在执行的任务，同时抛弃阻塞队列中的任务  |
| TIDYING    | 010       | 任务执行完毕，活动线程为0时，即将进入终结阶段 |
| TERMINATED | 011       | 终结状态                                      |

线程池状态和线程池中线程的数量由一个原子整型`ctl`来共同表示，使用一个数来表示两个值的主要原因是：可以通过一次CAS同时更改两个属性的值。

获取线程池状态、线程数量以及合并两个值的操作：

```java
// Packing and unpacking ctl
// 获取运行状态
// 该操作会让除高3位以外的数全部变为0
private static int runStateOf(int c)     { return c & ~CAPACITY; }

// 获取运行线程数
// 该操作会让高3位为0
private static int workerCountOf(int c)  { return c & CAPACITY; }

// 计算ctl新值
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

### 7.3.2 构造方法

也是构造自定义线程池的方法

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```

参数如下：

- `corePoolSize`：核心线程数，最多保留的线程数量
- `maximumPoolSize`：最大线程数，`maximumPoolSize - corePoolSize = 救急线程数`
- `keepAliveTime`：救急线程空闲时的最大生存时间
- `unit`：救急线程时间单位
  * `TimeUnit.DAYS`：天
  * `TimeUnit.HOURS`：小时
  * `TimeUnit.MINUTES`：分
  * `TimeUnit.SECONDS`：秒
  * `TimeUnit.MILLISECONDS`：毫秒
  * `TimeUnit.MICROSECONDS`：微妙
  * `TimeUnit.NANOSECONDS`：纳秒
- `workQueue`：阻塞队列（存放任务）
  * `ArrayBlockingQueue`：一个由数组结构组成的有界阻塞队列。
  * `LinkedBlockingQueue`：一个由链表结构组成的有界阻塞队列。
  * `SynchronousQueue`：一个不存储元素的阻塞队列，即直接提交给线程不保持它们，最多只有一个同步元素
  * `PriorityBlockingQueue`：优先队列，无界阻塞队列。
  * `DelayQueue`：一个使用优先级队列实现的无界阻塞队列，只有在延迟期满时才能从中提取元素。
  * `LinkedTransferQueue`：一个由链表结构组成的无界阻塞队列。与`SynchronousQueue`类似，还含有非阻塞方法。
  * `LinkedBlockingDeque`：一个由链表结构组成的双向阻塞队列。

- `threadFactory`：线程工厂（给线程取名字）主要用来创建线程，默认为正常优先级、非守护线程。
- `handler`：拒绝策略

**工作流程**

<img src="..\图片\1-06【并发】\12-2.png" />

线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。

当线程数达到 `corePoolSize` 并没有线程空闲，这时再加入任务，新加的任务会被加入`workQueue` 队列排队，直到有空闲的线程。

如果队列选择了有界队列，那么任务超过了队列大小时，会创建 `maximumPoolSize - corePoolSize` 数目的线程来救急。

如果线程到达 `maximumPoolSize` 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它著名框架也提供了实现。

- AbortPolicy：让调用者抛出 RejectedExecutionException 异常，这是默认策略
- CallerRunsPolicy：让调用者运行任务
- DiscardPolicy：放弃本次任务
- DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之

当高峰过去后，超过`corePoolSize` 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由`keepAliveTime` 和 `unit` 来控制。

### 7.3.3 拒绝策略

如果线程到达 `maximumPoolSize` 仍然有新任务这时会执行拒绝策略。 jdk拒绝策略提供了 4 种实现

<img src="..\图片\1-06【并发】\12-3拒绝策略.png" />

`AbortPolicy`让调用者抛出 `RejectedExecutionException` 异常，这是默认策略

- `DiscardOldestPolicy`：放弃队列中最早的任务，本任务取而代之。
- `DiscardPolicy`：放弃本次任务，不抛出异常，相当于静默处理。
- `CallerRunsPolicy`：让调用线程运行该任务。

```java
public class Demo1 {
   static AtomicInteger threadId = new AtomicInteger(0);

   public static void main(String[] args) {
      // 手动创建线程池
      // 创建有界阻塞队列
      ArrayBlockingQueue<Runnable> runnable = new ArrayBlockingQueue<Runnable>(10);
      // 创建线程工厂
      ThreadFactory threadFactory = new ThreadFactory() {
         @Override
         public Thread newThread(Runnable r) {
            Thread thread = new Thread(r, "working_thread_"+threadId.getAndIncrement());
            return thread;
         }
      };

      // 拒绝策略采用默认策略
      ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 7, 10, TimeUnit.SECONDS, runnable, threadFactory);

      for (int i = 0; i < 20; i++) {
         executor.execute(() -> {
            System.out.println(Thread.currentThread());
            try {
               Thread.sleep(100000);
            } catch (InterruptedException e) {
               e.printStackTrace();
            }
         });
      }
   }
}
```

```apl
PS D:\Java\vscode-java\javaweb>  & 'E:\JAVA\jdk1.8.0_144\bin\java.exe' '-cp' 'C:\Users\林轩\AppData\Local\Temp\cp_abfkrzwoogqmsaf8j8h24ydvp.jar' 'com.linxuan.thread.Demo' 
Thread[working_thread_0,5,main]
Exception in thread "main" Thread[working_thread_6,5,main]
Thread[working_thread_5,5,main]
Thread[working_thread_4,5,main]
Thread[working_thread_3,5,main]
Thread[working_thread_2,5,main]
Thread[working_thread_1,5,main]
java.util.concurrent.RejectedExecutionException: Task com.linxuan.thread.Demo$$Lambda$1/1674896058@1ae369b7 rejected from java.util.concurrent.ThreadPoolExecutor@6fffcba5[Running, pool size = 7, active threads 
= 7, queued tasks = 10, completed tasks = 0]
        at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
        at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
        at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
        at com.linxuan.thread.Demo.main(Demo.java:36)
```

我们使用 `DiscardPolicy` 的拒绝策略，它会忽略并抛弃当前任务的策略，实现代码如下：

```java
public static void main(String[] args) {
    // 任务的具体方法
    Runnable runnable = () -> {
        log.debug("任务被执行了");
        try {
            // 等待 1s
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    };

    // 创建线程,线程的任务队列的长度为 1
    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, 1, 100, TimeUnit.SECONDS,
                                                           new LinkedBlockingQueue<>(1),
                                                           new ThreadPoolExecutor.DiscardPolicy());
    // 添加并执行 4 个任务
    threadPool.execute(runnable);
    threadPool.execute(runnable);
    threadPool.execute(runnable);
    threadPool.execute(runnable);
}
```

我们创建了一个核心线程数和最大线程数都为 1 的线程池，并且给线程池的任务队列设置为 1，这样当存在 2 个以上的任务时就会触发拒绝策略，执行的结果如下图所示：

```apl
15:40:24.452 [pool-1-thread-1] DEBUG com.linxuan.demo01.Demo01 - 任务被执行了
15:40:25.463 [pool-1-thread-1] DEBUG com.linxuan.demo01.Demo01 - 任务被执行了
```

从上述结果可以看出只有两个任务被正确执行了，其他多余的任务就被舍弃并忽略了。其他拒绝策略的使用类似，这里就不一一赘述了。

### 7.3.4 自定义拒绝策略

除了 Java 自身提供的 4 种拒绝策略之外，我们也可以自定义拒绝策略，示例代码如下：

```java
public static void main(String[] args) {
    // 任务的具体方法
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("当前任务被执行,执行时间:" + new Date() +
                               " 执行线程:" + Thread.currentThread().getName());
            try {
                // 等待 1s
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    };
    // 创建线程,线程的任务队列的长度为 1
    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, 1, 100, TimeUnit.SECONDS, 
                                    	new LinkedBlockingQueue<>(1),
                                   		new RejectedExecutionHandler() {
        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            // 执行自定义拒绝策略的相关操作
            System.out.println("我是自定义拒绝策略~");
            }
        });
    
    // 添加并执行 4 个任务
    threadPool.execute(runnable);
    threadPool.execute(runnable);
    threadPool.execute(runnable);
    threadPool.execute(runnable);
}
```

```apl
我是自定义拒绝策略~
我是自定义拒绝策略~
当前任务被执行,执行时间:Thu Jun 22 14:19:58 CST 2023 执行线程:pool-1-thread-1
当前任务被执行,执行时间:Thu Jun 22 14:19:59 CST 2023 执行线程:pool-1-thread-1
```

### 7.3.5 提交任务

提交任务有三种方式：`execute()`、`submit()`以及`invoke()`。

* `execute()`方法：传入一个Runnable对象，执行其中的run方法。`execute()`方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。
* `submit()`方法：传入一个Callable对象，用Future来捕获返回值。`submit()`方法用于提交需要返回值的任务，线程池会返回一个`future`对象，可以通过该对象来判断任务是否执行成功。并且可以通过`future`的`get()`方法获取返回值，该方法会阻塞当前线程直到任务完成，使用`get(long timeout, TimeUnit unit)`方法会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完毕。
* `invokeAll()`方法：提交 tasks 中所有任务

**execute方法**

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();

    // 获取ctl
    int c = ctl.get();
    
    // 判断当前启用的线程数是否小于核心线程数
    if (workerCountOf(c) < corePoolSize) {
        // 为该任务分配线程
        if (addWorker(command, true))
            // 分配成功就返回
            return;
        
        // 分配失败再次获取ctl
        c = ctl.get();
    }
    
    // 分配和信息线程失败以后
    // 如果池状态为RUNNING并且插入到任务队列成功
    if (isRunning(c) && workQueue.offer(command)) {
        
        // 双重检测，可能在添加后线程池状态变为了非RUNNING
        int recheck = ctl.get();
        
        // 如果池状态为非RUNNING，则不会执行新来的任务
        // 将该任务从阻塞队列中移除
        if (!isRunning(recheck) && remove(command))
            // 调用拒绝策略，拒绝该任务的执行
            reject(command);
        
        // 如果没有正在运行的线程
        else if (workerCountOf(recheck) == 0)
            // 就创建新线程来执行该任务
            addWorker(null, false);
    }
    
    // 如果添加失败了（任务队列已满），就调用拒绝策略
    else if (!addWorker(command, false))
        reject(command);
}
```

其中调用了`addWoker()`方法，再看看看这个方法

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        // 如果池状态为非RUNNING状态、线程池为SHUTDOWN且该任务为空 或者阻塞队列中已经有任务
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            // 创建新线程失败
            return false;

        for (;;) {
            // 获得当前工作线程数
            int wc = workerCountOf(c);

            // 参数中 core 为true
            // CAPACITY 为 1 << COUNT_BITS-1，一般不会超过
            // 如果工作线程数大于了核心线程数，则创建失败
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // 通过CAS操作改变c的值
            if (compareAndIncrementWorkerCount(c))
                // 更改成功就跳出多重循环，且不再运行循环
                break retry;
            // 更改失败，重新获取ctl的值
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                // 跳出多重循环，且重新进入循环
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    // 用于标记work中的任务是否成功执行
    boolean workerStarted = false;
    // 用于标记worker是否成功加入了线程池中
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 创建新线程来执行任务
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            // 加锁
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                // 加锁的同时再次检测
                // 避免在释放锁之前调用了shut down
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    // 将线程添加到线程池中
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    // 添加成功标志位变为true
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            // 如果worker成功加入了线程池，就执行其中的任务
            if (workerAdded) {
                t.start();
                // 启动成功
                workerStarted = true;
            }
        }
    } finally {
        // 如果执行失败
        if (! workerStarted)
            // 调用添加失败的函数
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

**submit()方法**

传入一个Callable对象，用Future来捕获返回值

```java
Future<T> submit(Callable<T> task)
```

```java
@FunctionalInterface
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
```

```java
public static void main(String[] args) throws InterruptedException, ExecutionException {
    // 创建一个固定大小数量为2的线程池
    ExecutorService pool = Executors.newFixedThreadPool(2);
    // 通过submit执行Callable中的call方法
    // 通过Future来捕获返回值
    Future<String> future = pool.submit(() -> {
        log.debug("running");
        Thread.sleep(1000);
        return "ok";
    });
    // 查看捕获的返回值
    log.debug(future.get());
}
```

```apl
10:22:07.013 [pool-1-thread-1] DEBUG com.linxuan.demo01.Demo01 - running
10:22:08.023 [main] DEBUG com.linxuan.demo01.Demo01 - ok
```

**invoke方法**

```java
// 提交 tasks 中所有任务
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;
// 提交 tasks 中所有任务，带超时时间
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
    throws InterruptedException;
// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
<T> T invokeAny(Collection<? extends Callable<T>> tasks) 
    throws InterruptedException, ExecutionException;
// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
<T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
    throws InterruptedException, ExecutionException, TimeoutException;
```

```java
public static void main(String[] args) throws InterruptedException, ExecutionException {
    // 创建一个固定大小数量为2的线程池
    ExecutorService pool = Executors.newFixedThreadPool(2);

    List<Future<String>> futures = pool.invokeAll(Arrays.asList(
        () -> {
            log.debug("beging");
            Thread.sleep(1000);
            return "1";
        },
        () -> {
            log.debug("beging");
            Thread.sleep(500);
            return "2";
        },
        () -> {
            log.debug("beging");
            Thread.sleep(1500);
            return "3";
        }
    ));

    futures.forEach((Future f) -> {
        try {
            log.debug("{}", f.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    });
}
```

```java
10:38:41.621 [pool-1-thread-2] DEBUG com.linxuan.demo01.Demo01 - beging
10:38:41.621 [pool-1-thread-1] DEBUG com.linxuan.demo01.Demo01 - beging
10:38:42.136 [pool-1-thread-2] DEBUG com.linxuan.demo01.Demo01 - beging
10:38:43.645 [main] DEBUG com.linxuan.demo01.Demo01 - 1
10:38:43.649 [main] DEBUG com.linxuan.demo01.Demo01 - 2
10:38:43.649 [main] DEBUG com.linxuan.demo01.Demo01 - 3
```

### 7.3.6 关闭线程池

关闭线程池有两种方式：`shutdown()`和`shutdownNow()`。

**shutdown方法**

```java
/*
线程池状态变为 SHUTDOWN
    - 不会接收新任务
    - 但已提交任务会执行完
    - 此方法不会阻塞调用线程的执行
*/
void shutdown();
```

源码如下：

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 修改线程池状态
        advanceRunState(SHUTDOWN);
        // 仅会打断空闲线程
        interruptIdleWorkers();
        onShutdown(); // 扩展点 ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    // 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)
    tryTerminate();
}
```

**shutdownNow方法**

```java
/*
线程池状态变为 STOP
    - 不会接收新任务
    - 会将队列中的任务返回
    - 并用 interrupt 的方式中断正在执行的任务
*/
List<Runnable> shutdownNow();
```

源码如下：

```java
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 修改线程池状态
        advanceRunState(STOP);
        // 打断所有线程
        interruptWorkers();
        // 获取队列中剩余任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    // 尝试终结
    tryTerminate();
    return tasks;
}
```

**其他方法**

```java
// 不在 RUNNING 状态的线程池，此方法就返回 true
boolean isShutdown();
// 线程池状态是否是 TERMINATED
boolean isTerminated();
// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待
boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
```

## 7.4 Executors创建线程池

### FixedThreadPool

`Executors.newFixedThreadPool`：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；

源码如下：

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

- 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间
- 阻塞队列是无界的，可以放任意数量的任务
- 适用于任务量已知，相对耗时的任务

使用示例如下：

```java
public static void fixedThreadPool() {
    // 创建 2 个数据级的线程池
    ExecutorService threadPool = Executors.newFixedThreadPool(2);

    // 创建任务
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("任务被执行,线程:" + Thread.currentThread().getName());
        }
    };

    // 线程池执行任务(一次添加 4 个任务)
    // 执行任务的方法有两种:submit 和 execute
    threadPool.submit(runnable);  // 执行方式 1:submit
    threadPool.execute(runnable); // 执行方式 2:execute
    threadPool.execute(runnable);
    threadPool.execute(runnable);
}
```


如果觉得以上方法比较繁琐，还用更简单的使用方法，如下代码所示：

```java
public static void fixedThreadPool() {
    // 创建线程池
    ExecutorService threadPool = Executors.newFixedThreadPool(2);
    // 执行任务
    threadPool.execute(() -> {
        System.out.println("任务被执行,线程:" + Thread.currentThread().getName());
    });
}
```

我们也可以利用它的另一个重载方法来自定义线程工厂

```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>(),
                                  threadFactory);
}
```

### CachedThreadPool

`Executors.newCachedThreadPool`：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；

源码如下：

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

- 没有核心线程，最大线程数为`Integer.MAX_VALUE`，所有创建的线程都是救急线程，空闲时生存时间为60秒

- 阻塞队列使用的是`SynchronousQueue`，`SynchronousQueue`是一种特殊的队列。没有容量，没有线程来取是放不进去的，只有当线程取任务时，才会将任务放入该阻塞队列中。

  ```java
  public static void main(String[] args) {
      SynchronousQueue<Integer> integers = new SynchronousQueue<>();
      new Thread(() -> {
          try {
              log.debug("putting {} ", 1);
              integers.put(1);
              log.debug("{} putted...", 1);
              log.debug("putting...{} ", 2);
              integers.put(2);
              log.debug("{} putted...", 2);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }, "t1").start();
  
      sleep(1);
  
      new Thread(() -> {
          try {
              log.debug("taking {}", 1);
              integers.take();
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }, "t2").start();
  
      sleep(1);
  
      new Thread(() -> {
          try {
              log.debug("taking {}", 2);
              integers.take();
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }, "t3").start();
  }
  ```
  
  ```apl
  11:48:15.500 c.TestSynchronousQueue [t1] - putting 1 
  11:48:16.500 c.TestSynchronousQueue [t2] - taking 1 
  11:48:16.500 c.TestSynchronousQueue [t1] - 1 putted... 
  11:48:16.500 c.TestSynchronousQueue [t1] - putting...2 
  11:48:17.502 c.TestSynchronousQueue [t3] - taking 2 
  11:48:17.503 c.TestSynchronousQueue [t1] - 2 putted... 
  ```

使用示例如下：

```java
public static void cachedThreadPool() {
    // 创建线程池
    ExecutorService threadPool = Executors.newCachedThreadPool();
    // 执行任务
    for (int i = 0; i < 10; i++) {
        threadPool.execute(() -> {
            System.out.println("任务被执行,线程:" + Thread.currentThread().getName());
        });
    }
}
```

线程池创建了 10 个线程来执行相应的任务。整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况。

### SingleThreadExecutor

`Executors.newSingleThreadExecutor`：创建单个线程数的线程池，它可以保证先进先出的执行顺序；

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

内部调用了`new ThreadPoolExecutor`的构造方法，传入的`corePoolSize`和`maximumPoolSize`都为1。然后将该对象传给了`FinalizableDelegatedExecutorService`。该类修饰了`ThreadPoolExecutor`，让外部无法调用`ThreadPoolExecutor`内部的某些方法来修改所创建的线程池的大小。

`SingleThread`创建单个线程和自己创建一个线程来运行多个任务的区别：当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而SingleThread会创建一个新线程，继续执行任务队列中剩余的任务。

`SingleThread`和`newFixedThreadPool(1)`的区别：`newFixedThreadPool(1)`传值为1，可以将`FixedThreadPool`强转为`ThreadPoolExecutor`，然后通过`setCorePoolSize`改变核心线程数。而`SingleThread`无法修改核心线程数

```java
// 强转为ThreadPoolExecutor
ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(1);
// 改变核心线程数
threadPool.setCorePoolSize(2);
```

使用示例如下：

```java
public static void singleThreadExecutor() {
    // 创建线程池
    ExecutorService threadPool = Executors.newSingleThreadExecutor();
    // 执行任务
    for (int i = 0; i < 10; i++) {
        final int index = i;
        threadPool.execute(() -> {
            System.out.println(index + ":任务被执行");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
            }
        });
    }
}
```

### ScheduledThreadPool

`Executors.newScheduledThreadPool`：创建一个可以执行延迟任务的线程池；

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
```

```java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
```

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
```

使用示例如下：

```java
public static void scheduledThreadPool() {
    // 创建线程池
    ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(5);
    // 添加定时执行任务(1s 后执行)
    System.out.println("添加任务,时间:" + new Date());
    threadPool.schedule(() -> {
        System.out.println("任务被执行,时间:" + new Date());
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
        }
    }, 1, TimeUnit.SECONDS);
}
```

执行结果如下：

```apl
添加任务,时间:Fri Oct 14 14:44:12 CST 2022
任务被执行,时间:Fri Oct 14 14:44:13 CST 2022
```

从上述结果可以看出，任务在 1 秒之后被执行了，符合我们的预期。

### SingleThreadScheduledExecutor

`Executors.newSingleThreadScheduledExecutor`：创建一个单线程的可以执行延迟任务的线程池；

源码如下：

```java
public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
    return new DelegatedScheduledExecutorService
        (new ScheduledThreadPoolExecutor(1));
}
```

```java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
```

使用示例如下：

```java
public static void SingleThreadScheduledExecutor() {
    // 创建线程池
    ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor();
    // 添加定时执行任务(2s 后执行)
    System.out.println("添加任务,时间:" + new Date());
    threadPool.schedule(() -> {
        System.out.println("任务被执行,时间:" + new Date());
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
        }
    }, 2, TimeUnit.SECONDS);
}
```

执行结果如下：

```apl
添加任务,时间:Fri Oct 14 14:47:13 CST 2022
任务被执行,时间:Fri Oct 14 14:47:15 CST 2022
```


从上述结果可以看出，任务在 2 秒之后被执行了，符合我们的预期。

### WorkStealingPool

`Executors.newWorkStealingPool`：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。

使用示例如下：

```java
public static void workStealingPool() {
    // 创建线程池
    ExecutorService threadPool = Executors.newWorkStealingPool();
    // 执行任务
    for (int i = 0; i < 10; i++) {
        final int index = i;
        threadPool.execute(() -> {
            System.out.println(index + " 被执行,线程名:" + Thread.currentThread().getName());
        });
    }
    // 确保任务执行完成
    while (!threadPool.isTerminated()) {
    }
}
```

执行结果如下：

```apl
0 被执行,线程名:ForkJoinPool-1-worker-1
3 被执行,线程名:ForkJoinPool-1-worker-4
2 被执行,线程名:ForkJoinPool-1-worker-3
1 被执行,线程名:ForkJoinPool-1-worker-2
9 被执行,线程名:ForkJoinPool-1-worker-0
8 被执行,线程名:ForkJoinPool-1-worker-4
5 被执行,线程名:ForkJoinPool-1-worker-1
7 被执行,线程名:ForkJoinPool-1-worker-7
6 被执行,线程名:ForkJoinPool-1-worker-6
4 被执行,线程名:ForkJoinPool-1-worker-5
```

从上述结果可以看出，任务的执行顺序是不确定的，因为它是抢占式执行的。

## 7.5 线程池的选用

经过以上的学习我们对整个线程池也有了一定的认识了，那究竟该如何选择线程池呢？来看下阿里巴巴《Java开发手册》的答案：

> 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
>
> 说明：Executors 返回的线程池对象的弊端如下：
>
> 1. FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
> 2. CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。

所以综上情况所述，推荐使用 `ThreadPoolExecutor` 的方式进行线程池的创建，因为这种创建方式更可控，并且更加明确了线程池的运行规则，可以规避一些未知的风险。

## 7.6 异步模式之工作线程

模式之Worker Thread：让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。

例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）。

注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率。

例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工。

### 7.6.1 饥饿

固定大小线程池会有饥饿现象：

- 两个工人是同一个线程池中的两个线程，他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作。
- 客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待。后厨做菜：没啥说的，做就是了
- 比如工人A 处理了点餐任务，接下来它要等着工人B 把菜做好，然后上菜，他俩也配合的蛮好。
- 但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，这就是饥饿。

下面来看一下：

```java
@Slf4j
public class Demo01 {
   static final List<String> MENU = Arrays.asList("地三鲜", "宫保鸡丁", "辣子鸡丁", "烤鸡翅");
   static Random RANDOM = new Random();

   static String cooking() {
      return MENU.get(RANDOM.nextInt(MENU.size()));
   }

   public static void main(String[] args) {
      ExecutorService executorService = Executors.newFixedThreadPool(2);
      executorService.execute(() -> {
         log.debug("处理点餐...");
         Future<String> f = executorService.submit(() -> {
            log.debug("做菜");
            return cooking();
         });
         try {
            log.debug("上菜: {}", f.get());
         } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
         }
      });
      /*  
         executorService.execute(() -> {
            log.debug("处理点餐...");
            Future<String> f = executorService.submit(() -> {
               log.debug("做菜");
               return cooking();
            });
            try {
               log.debug("上菜: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
               e.printStackTrace();
            }
         });
      */
   }
}
```

正常情况下，注释内容没有打开，打印如下：

```apl
17:21:27.883 c.TestDeadLock [pool-1-thread-1] - 处理点餐...
17:21:27.891 c.TestDeadLock [pool-1-thread-2] - 做菜
17:21:27.891 c.TestDeadLock [pool-1-thread-1] - 上菜: 烤鸡翅
```

当注释取消后，可能的输出

```apl
17:08:41.339 c.TestDeadLock [pool-1-thread-2] - 处理点餐... 
17:08:41.339 c.TestDeadLock [pool-1-thread-1] - 处理点餐... 
```

注释取消，就出现了饥饿的现象。这并不等同于死锁，死锁是互相持有对方的锁，与`synchronized`有关，而这个是线程池不够用了，所以叫做饥饿。

注释打开，两个线程都在处理点餐，这时线程池并没有空闲线程，并不能够去做菜，所以就会出现饥饿现象。如果我们仅仅来修改线程池的大小，这并不能够解决根本问题，所以我们需要使用别的方法来解决：不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率。

```java
public class TestDeadLock {
    static final List<String> MENU = Arrays.asList("地三鲜", "宫保鸡丁", "辣子鸡丁", "烤鸡翅");
    static Random RANDOM = new Random();
    static String cooking() {
        return MENU.get(RANDOM.nextInt(MENU.size()));
    }
    
    public static void main(String[] args) {
        ExecutorService waiterPool = Executors.newFixedThreadPool(1);
        ExecutorService cookPool = Executors.newFixedThreadPool(1);
        
        waiterPool.execute(() -> {
            log.debug("处理点餐...");
            Future<String> f = cookPool.submit(() -> {
                log.debug("做菜");
                return cooking();
            });
            try {
                log.debug("上菜: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        
        waiterPool.execute(() -> {
            log.debug("处理点餐...");
            Future<String> f = cookPool.submit(() -> {
                log.debug("做菜");
                return cooking();
            });
            try {
                log.debug("上菜: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
    }
}
```

### 7.6.2 创建线程池个数

创建多少线程池合适？这是一个问题：

- 过小会导致程序不能充分地利用系统资源、容易导致饥饿
- 过大会导致更多的线程上下文切换，占用更多内存

对此有两种方法运算： CPU 密集型运算和I/O 密集型运算

**CPU 密集型运算**

通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率，`+1` 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费。

**I/O 密集型运算**

CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。

经验公式如下：`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间`

- 例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式：`4 * 100% * 100% / 50% = 8`
- 例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式：`4 * 100% * 100% / 10% = 40`

## 7.7 任务调度线程池

在『任务调度线程池』功能加入之前，可以使用 `java.util.Timer` 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。

```java
public static void main(String[] args) {
    Timer timer = new Timer();
    TimerTask task1 = new TimerTask() {
        @Override
        public void run() {
            log.debug("task 1");
            sleep(2);
        }
    };
    TimerTask task2 = new TimerTask() {
        @Override
        public void run() {
            log.debug("task 2");
        }
    };
    // 使用 timer 添加两个任务，希望它们都在 1s 后执行
    // 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行
    timer.schedule(task1, 1000);
    timer.schedule(task2, 1000);
}
```

```apl
20:46:09.444 c.TestTimer [main] - start... 
20:46:10.447 c.TestTimer [Timer-0] - task 1 
20:46:12.448 c.TestTimer [Timer-0] - task 2 
```

使用 `ScheduledExecutorService` 改写：

```java
ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
// 添加两个任务，希望它们都在 1s 后执行
executor.schedule(() -> {
    System.out.println("任务1，执行时间：" + new Date());
    try { Thread.sleep(2000); } catch (InterruptedException e) { }
}, 1000, TimeUnit.MILLISECONDS);
executor.schedule(() -> {
    System.out.println("任务2，执行时间：" + new Date());
}, 1000, TimeUnit.MILLISECONDS);
```

```apl
任务1，执行时间：Thu Jan 03 12:45:17 CST 2019 
任务2，执行时间：Thu Jan 03 12:45:17 CST 2019 
```

`scheduleAtFixedRate` 例子：

```java
// 定时
ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
log.debug("start...");
pool.scheduleAtFixedRate(() -> {
    log.debug("running...");
}, 1, 1, TimeUnit.SECONDS);
```

```apl
21:45:43.167 c.TestTimer [main] - start... 
21:45:44.215 c.TestTimer [pool-1-thread-1] - running... 
21:45:45.215 c.TestTimer [pool-1-thread-1] - running... 
21:45:46.215 c.TestTimer [pool-1-thread-1] - running... 
21:45:47.215 c.TestTimer [pool-1-thread-1] - running... 
```

`scheduleAtFixedRate` 例子（任务执行时间超过了间隔时间）：

```java
ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
log.debug("start...");
pool.scheduleAtFixedRate(() -> {
    log.debug("running...");
    sleep(2);
}, 1, 1, TimeUnit.SECONDS);
```

输出分析：一开始，延时 1s，接下来，由于任务执行时间 > 间隔时间，间隔被『撑』到了 2s

```java
21:44:30.311 c.TestTimer [main] - start... 
21:44:31.360 c.TestTimer [pool-1-thread-1] - running... 
21:44:33.361 c.TestTimer [pool-1-thread-1] - running... 
21:44:35.362 c.TestTimer [pool-1-thread-1] - running... 
21:44:37.362 c.TestTimer [pool-1-thread-1] - running... 
```

scheduleWithFixedDelay 例子：

```java
ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
log.debug("start...");
pool.scheduleWithFixedDelay(()-> {
    log.debug("running...");
    sleep(2);
}, 1, 1, TimeUnit.SECONDS);
```

输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 <-> 延时 <-> 下一个任务开始 所 以间隔都是 3s

```apl
21:40:55.078 c.TestTimer [main] - start... 
21:40:56.140 c.TestTimer [pool-1-thread-1] - running... 
21:40:59.143 c.TestTimer [pool-1-thread-1] - running... 
21:41:02.145 c.TestTimer [pool-1-thread-1] - running... 
21:41:05.147 c.TestTimer [pool-1-thread-1] - running... 
```

整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线 程也不会被释放。用来执行延迟或反复执行的任务

